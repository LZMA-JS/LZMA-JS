{"version":3,"file":"lzma_worker-min.mjs","sources":["lzma-algo.mjs","lzma_worker.mjs"],"sourcesContent":["/// Â© 2015 Nathan Rugg <nmrugg@gmail.com> | MIT\n/// See LICENSE for more details.\n\n/* jshint noarg:true, boss:true, unused:strict, strict:true, undef:true, noarg: true, forin:true, evil:true, newcap:false, -W041, -W021, worker:true, browser:true, node:true */\n\n/* global setImmediate, setTimeout, window, onmessage */\n\n/** xs */\n///NOTE: This is the master file that is used to generate lzma-c.js and lzma-d.js.\n///      Comments are used to determine which parts are to be removed.\n///\n/// cs-ce (compression start-end)\n/// ds-de (decompression start-end)\n/// xs-xe (only in this file start-end)\n/// co    (compression only)\n/// do    (decompression only)\n/** xe */\n\nexport var action_compress = 1;\nexport var action_decompress = 2;\nexport var action_progress = 3;\n\nvar wait = typeof setImmediate == \"function\" ? setImmediate : setTimeout,\n    __4294967296 = 4294967296,\n    N1_longLit = [4294967295, -__4294967296],\n    /** cs */\n    MIN_VALUE = [0, -9223372036854775808],\n    /** ce */\n    P0_longLit = [0, 0],\n    P1_longLit = [1, 0];\n\nfunction update_progress(percent, cbn) {\n    postMessage({\n        \"action\": action_progress,\n        \"cbn\": cbn,\n        \"result\": percent\n    });\n}\n\nfunction initDim(len) {\n    ///NOTE: This is MUCH faster than \"new Array(len)\" in newer versions of v8 (starting with Node.js 0.11.15, which uses v8 3.28.73).\n    var a = [];\n    a[len - 1] = undefined;\n    return a;\n}\n\nfunction add(a, b) {\n    return create(a[0] + b[0], a[1] + b[1]);\n}\n\n/** cs */\nfunction and(a, b) {\n    return makeFromBits(~~Math.max(Math.min(a[1] / __4294967296, 2147483647), -2147483648) & ~~Math.max(Math.min(b[1] / __4294967296, 2147483647), -2147483648), lowBits_0(a) & lowBits_0(b));\n}\n/** ce */\n\nfunction compare(a, b) {\n    var nega, negb;\n    if (a[0] == b[0] && a[1] == b[1]) {\n        return 0;\n    }\n    nega = a[1] < 0;\n    negb = b[1] < 0;\n    if (nega && !negb) {\n        return -1;\n    }\n    if (!nega && negb) {\n        return 1;\n    }\n    if (sub(a, b)[1] < 0) {\n        return -1;\n    }\n    return 1;\n}\n\nfunction create(valueLow, valueHigh) {\n    var diffHigh, diffLow;\n    valueHigh %= 1.8446744073709552E19;\n    valueLow %= 1.8446744073709552E19;\n    diffHigh = valueHigh % __4294967296;\n    diffLow = Math.floor(valueLow / __4294967296) * __4294967296;\n    valueHigh = valueHigh - diffHigh + diffLow;\n    valueLow = valueLow - diffLow + diffHigh;\n    while (valueLow < 0) {\n        valueLow += __4294967296;\n        valueHigh -= __4294967296;\n    }\n    while (valueLow > 4294967295) {\n        valueLow -= __4294967296;\n        valueHigh += __4294967296;\n    }\n    valueHigh = valueHigh % 1.8446744073709552E19;\n    while (valueHigh > 9223372032559808512) {\n        valueHigh -= 1.8446744073709552E19;\n    }\n    while (valueHigh < -9223372036854775808) {\n        valueHigh += 1.8446744073709552E19;\n    }\n    return [valueLow, valueHigh];\n}\n\n/** cs */\nfunction eq(a, b) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n/** ce */\nfunction fromInt(value) {\n    if (value >= 0) {\n        return [value, 0];\n    } else {\n        return [value + __4294967296, -__4294967296];\n    }\n}\n\nfunction lowBits_0(a) {\n    if (a[0] >= 2147483648) {\n        return ~~Math.max(Math.min(a[0] - __4294967296, 2147483647), -2147483648);\n    } else {\n        return ~~Math.max(Math.min(a[0], 2147483647), -2147483648);\n    }\n}\n/** cs */\nfunction makeFromBits(highBits, lowBits) {\n    var high, low;\n    high = highBits * __4294967296;\n    low = lowBits;\n    if (lowBits < 0) {\n        low += __4294967296;\n    }\n    return [low, high];\n}\n\nfunction pwrAsDouble(n) {\n    if (n <= 30) {\n        return 1 << n;\n    } else {\n        return pwrAsDouble(30) * pwrAsDouble(n - 30);\n    }\n}\n\nfunction shl(a, n) {\n    var diff, newHigh, newLow, twoToN;\n    n &= 63;\n    if (eq(a, MIN_VALUE)) {\n        if (!n) {\n            return a;\n        }\n        return P0_longLit;\n    }\n    if (a[1] < 0) {\n        throw new Error(\"Neg\");\n    }\n    twoToN = pwrAsDouble(n);\n    newHigh = a[1] * twoToN % 1.8446744073709552E19;\n    newLow = a[0] * twoToN;\n    diff = newLow - newLow % __4294967296;\n    newHigh += diff;\n    newLow -= diff;\n    if (newHigh >= 9223372036854775807) {\n        newHigh -= 1.8446744073709552E19;\n    }\n    return [newLow, newHigh];\n}\n\nfunction shr(a, n) {\n    var shiftFact;\n    n &= 63;\n    shiftFact = pwrAsDouble(n);\n    return create(Math.floor(a[0] / shiftFact), a[1] / shiftFact);\n}\n\nfunction shru(a, n) {\n    var sr;\n    n &= 63;\n    sr = shr(a, n);\n    if (a[1] < 0) {\n        sr = add(sr, shl([2, 0], 63 - n));\n    }\n    return sr;\n}\n\n/** ce */\n\nfunction sub(a, b) {\n    return create(a[0] - b[0], a[1] - b[1]);\n}\n\nfunction $ByteArrayInputStream(this$static, buf) {\n    this$static.buf = buf;\n    this$static.pos = 0;\n    this$static.count = buf.length;\n    return this$static;\n}\n\n/** ds */\nfunction $read(this$static) {\n    if (this$static.pos >= this$static.count)\n        return -1;\n    return this$static.buf[this$static.pos++] & 255;\n}\n/** de */\n/** cs */\nfunction $read_0(this$static, buf, off, len) {\n    if (this$static.pos >= this$static.count)\n        return -1;\n    len = Math.min(len, this$static.count - this$static.pos);\n    arraycopy(this$static.buf, this$static.pos, buf, off, len);\n    this$static.pos += len;\n    return len;\n}\n/** ce */\n\nfunction $ByteArrayOutputStream(this$static) {\n    this$static.buf = initDim(32);\n    this$static.count = 0;\n    return this$static;\n}\n\nfunction $toByteArray(this$static) {\n    var data = this$static.buf;\n    data.length = this$static.count;\n    return data;\n}\n\n/** cs */\nfunction $write(this$static, b) {\n    this$static.buf[this$static.count++] = b << 24 >> 24;\n}\n/** ce */\n\nfunction $write_0(this$static, buf, off, len) {\n    arraycopy(buf, off, this$static.buf, this$static.count, len);\n    this$static.count += len;\n}\n\n/** cs */\nfunction $getChars(this$static, srcBegin, srcEnd, dst, dstBegin) {\n    var srcIdx;\n    for (srcIdx = srcBegin; srcIdx < srcEnd; ++srcIdx) {\n        dst[dstBegin++] = this$static.charCodeAt(srcIdx);\n    }\n}\n/** ce */\n\nfunction arraycopy(src, srcOfs, dest, destOfs, len) {\n    for (var i = 0; i < len; ++i) {\n        dest[destOfs + i] = src[srcOfs + i];\n    }\n}\n\n/** cs */\nfunction $configure(this$static, encoder) {\n    $SetDictionarySize_0(encoder, 1 << this$static.s);\n    encoder._numFastBytes = this$static.f;\n    $SetMatchFinder(encoder, this$static.m);\n    \n    /// lc is always 3\n    /// lp is always 0\n    /// pb is always 2\n    encoder._numLiteralPosStateBits = 0;\n    encoder._numLiteralContextBits = 3;\n    encoder._posStateBits = 2;\n    ///this$static._posStateMask = (1 << pb) - 1;\n    encoder._posStateMask = 3;\n}\n\nfunction $init(this$static, input, output, length_0, mode) {\n    var encoder, i;\n    if (compare(length_0, N1_longLit) < 0)\n        throw new Error(\"invalid length \" + length_0);\n    this$static.length_0 = length_0;\n    encoder = $Encoder({});\n    $configure(mode, encoder);\n    //encoder._writeEndMark = typeof LZMA.disableEndMark == \"undefined\";\n    $WriteCoderProperties(encoder, output);\n    for (i = 0; i < 64; i += 8)\n        $write(output, lowBits_0(shr(length_0, i)) & 255);\n    this$static.chunker = (encoder._needReleaseMFStream = 0 , (encoder._inStream = input , encoder._finished = 0 , $Create_2(encoder) , encoder._rangeEncoder.Stream = output , $Init_4(encoder) , $FillDistancesPrices(encoder) , $FillAlignPrices(encoder) , encoder._lenEncoder._tableSize = encoder._numFastBytes + 1 - 2 , $UpdateTables(encoder._lenEncoder, 1 << encoder._posStateBits) , encoder._repMatchLenEncoder._tableSize = encoder._numFastBytes + 1 - 2 , $UpdateTables(encoder._repMatchLenEncoder, 1 << encoder._posStateBits) , encoder.nowPos64 = P0_longLit , undefined) , $Chunker_0({}, encoder));\n}\n\nfunction $LZMAByteArrayCompressor(this$static, data, mode) {\n    this$static.output = $ByteArrayOutputStream({});\n    $init(this$static, $ByteArrayInputStream({}, data), this$static.output, fromInt(data.length), mode);\n    return this$static;\n}\n/** ce */\n\n/** ds */\nfunction $init_0(this$static, input, output) {\n    var decoder,\n        hex_length = \"\",\n        i,\n        properties = [],\n        r,\n        tmp_length;\n    \n    for (i = 0; i < 5; ++i) {\n        r = $read(input);\n        if (r == -1)\n            throw new Error(\"truncated input\");\n        properties[i] = r << 24 >> 24;\n    }\n    \n    decoder = $Decoder({});\n    if (!$SetDecoderProperties(decoder, properties)) {\n        throw new Error(\"corrupted input\");\n    }\n    for (i = 0; i < 64; i += 8) {\n        r = $read(input);\n        if (r == -1)\n            throw new Error(\"truncated input\");\n        r = r.toString(16);\n        if (r.length == 1) r = \"0\" + r;\n        hex_length = r + \"\" + hex_length;\n    }\n    \n    /// Was the length set in the header (if it was compressed from a stream, the length is all f\"s).\n    if (/^0+$|^f+$/i.test(hex_length)) {\n        /// The length is unknown, so set to -1.\n        this$static.length_0 = N1_longLit;\n    } else {\n        ///NOTE: If there is a problem with the decoder because of the length, you can always set the length to -1 (N1_longLit) which means unknown.\n        tmp_length = parseInt(hex_length, 16);\n        /// If the length is too long to handle, just set it to unknown.\n        if (tmp_length > 4294967295) {\n            this$static.length_0 = N1_longLit;\n        } else {\n            this$static.length_0 = fromInt(tmp_length);\n        }\n    }\n    \n    this$static.chunker = $CodeInChunks(decoder, input, output, this$static.length_0);\n}\n\nfunction $LZMAByteArrayDecompressor(this$static, data) {\n    this$static.output = $ByteArrayOutputStream({});\n    $init_0(this$static, $ByteArrayInputStream({}, data), this$static.output);\n    return this$static;\n}\n/** de */\n/** cs */\nfunction $Create_4(this$static, keepSizeBefore, keepSizeAfter, keepSizeReserv) {\n    var blockSize;\n    this$static._keepSizeBefore = keepSizeBefore;\n    this$static._keepSizeAfter = keepSizeAfter;\n    blockSize = keepSizeBefore + keepSizeAfter + keepSizeReserv;\n    if (this$static._bufferBase == null || this$static._blockSize != blockSize) {\n        this$static._bufferBase = null;\n        this$static._blockSize = blockSize;\n        this$static._bufferBase = initDim(this$static._blockSize);\n    }\n    this$static._pointerToLastSafePosition = this$static._blockSize - keepSizeAfter;\n}\n\nfunction $GetIndexByte(this$static, index) {\n    return this$static._bufferBase[this$static._bufferOffset + this$static._pos + index];\n}\n\nfunction $GetMatchLen(this$static, index, distance, limit) {\n    var i, pby;\n    if (this$static._streamEndWasReached) {\n        if (this$static._pos + index + limit > this$static._streamPos) {\n            limit = this$static._streamPos - (this$static._pos + index);\n        }\n    }\n    ++distance;\n    pby = this$static._bufferOffset + this$static._pos + index;\n    for (i = 0; i < limit && this$static._bufferBase[pby + i] == this$static._bufferBase[pby + i - distance]; ++i) {\n    }\n    return i;\n}\n\nfunction $GetNumAvailableBytes(this$static) {\n    return this$static._streamPos - this$static._pos;\n}\n\nfunction $MoveBlock(this$static) {\n    var i, numBytes, offset;\n    offset = this$static._bufferOffset + this$static._pos - this$static._keepSizeBefore;\n    if (offset > 0) {\n        --offset;\n    }\n    numBytes = this$static._bufferOffset + this$static._streamPos - offset;\n    for (i = 0; i < numBytes; ++i) {\n        this$static._bufferBase[i] = this$static._bufferBase[offset + i];\n    }\n    this$static._bufferOffset -= offset;\n}\n\nfunction $MovePos_1(this$static) {\n    var pointerToPostion;\n    this$static._pos += 1;\n    if (this$static._pos > this$static._posLimit) {\n        pointerToPostion = this$static._bufferOffset + this$static._pos;\n        if (pointerToPostion > this$static._pointerToLastSafePosition) {\n            $MoveBlock(this$static);\n        }\n        $ReadBlock(this$static);\n    }\n}\n\nfunction $ReadBlock(this$static) {\n    var numReadBytes, pointerToPostion, size;\n    if (this$static._streamEndWasReached)\n        return;\n    while (1) {\n        size = -this$static._bufferOffset + this$static._blockSize - this$static._streamPos;\n        if (!size)\n            return;\n        numReadBytes = $read_0(this$static._stream, this$static._bufferBase, this$static._bufferOffset + this$static._streamPos, size);\n        if (numReadBytes == -1) {\n            this$static._posLimit = this$static._streamPos;\n            pointerToPostion = this$static._bufferOffset + this$static._posLimit;\n            if (pointerToPostion > this$static._pointerToLastSafePosition) {\n                this$static._posLimit = this$static._pointerToLastSafePosition - this$static._bufferOffset;\n            }\n            this$static._streamEndWasReached = 1;\n            return;\n        }\n        this$static._streamPos += numReadBytes;\n        if (this$static._streamPos >= this$static._pos + this$static._keepSizeAfter) {\n            this$static._posLimit = this$static._streamPos - this$static._keepSizeAfter;\n        }\n    }\n}\n\nfunction $ReduceOffsets(this$static, subValue) {\n    this$static._bufferOffset += subValue;\n    this$static._posLimit -= subValue;\n    this$static._pos -= subValue;\n    this$static._streamPos -= subValue;\n}\n\nvar CrcTable = (function () {\n    var i, j, r, CrcTable = [];\n    for (i = 0; i < 256; ++i) {\n        r = i;\n        for (j = 0; j < 8; ++j)\n        if ((r & 1) != 0) {\n            r >>>= 1;\n            r ^= -306674912;\n        } else {\n            r >>>= 1;\n        }\n        CrcTable[i] = r;\n    }\n    return CrcTable;\n}());\n\nfunction $Create_3(this$static, historySize, keepAddBufferBefore, matchMaxLen, keepAddBufferAfter) {\n    var cyclicBufferSize, hs, windowReservSize;\n    if (historySize < 1073741567) {\n        this$static._cutValue = 16 + (matchMaxLen >> 1);\n        windowReservSize = ~~((historySize + keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2) + 256;\n        $Create_4(this$static, historySize + keepAddBufferBefore, matchMaxLen + keepAddBufferAfter, windowReservSize);\n        this$static._matchMaxLen = matchMaxLen;\n        cyclicBufferSize = historySize + 1;\n        if (this$static._cyclicBufferSize != cyclicBufferSize) {\n            this$static._son = initDim((this$static._cyclicBufferSize = cyclicBufferSize) * 2);\n        }\n\n        hs = 65536;\n        if (this$static.HASH_ARRAY) {\n            hs = historySize - 1;\n            hs |= hs >> 1;\n            hs |= hs >> 2;\n            hs |= hs >> 4;\n            hs |= hs >> 8;\n            hs >>= 1;\n            hs |= 65535;\n            if (hs > 16777216)\n            hs >>= 1;\n            this$static._hashMask = hs;\n            hs += 1;\n            hs += this$static.kFixHashSize;\n        }\n        \n        if (hs != this$static._hashSizeSum) {\n            this$static._hash = initDim(this$static._hashSizeSum = hs);\n        }\n    }\n}\n\nfunction $GetMatches(this$static, distances) {\n    var count, cur, curMatch, curMatch2, curMatch3, cyclicPos, delta, hash2Value, hash3Value, hashValue, len, len0, len1, lenLimit, matchMinPos, maxLen, offset, pby1, ptr0, ptr1, temp;\n    if (this$static._pos + this$static._matchMaxLen <= this$static._streamPos) {\n        lenLimit = this$static._matchMaxLen;\n    } else {\n        lenLimit = this$static._streamPos - this$static._pos;\n        if (lenLimit < this$static.kMinMatchCheck) {\n            $MovePos_0(this$static);\n            return 0;\n        }\n    }\n    offset = 0;\n    matchMinPos = this$static._pos > this$static._cyclicBufferSize?this$static._pos - this$static._cyclicBufferSize:0;\n    cur = this$static._bufferOffset + this$static._pos;\n    maxLen = 1;\n    hash2Value = 0;\n    hash3Value = 0;\n    if (this$static.HASH_ARRAY) {\n        temp = CrcTable[this$static._bufferBase[cur] & 255] ^ this$static._bufferBase[cur + 1] & 255;\n        hash2Value = temp & 1023;\n        temp ^= (this$static._bufferBase[cur + 2] & 255) << 8;\n        hash3Value = temp & 65535;\n        hashValue = (temp ^ CrcTable[this$static._bufferBase[cur + 3] & 255] << 5) & this$static._hashMask;\n    } else {\n        hashValue = this$static._bufferBase[cur] & 255 ^ (this$static._bufferBase[cur + 1] & 255) << 8;\n    }\n\n    curMatch = this$static._hash[this$static.kFixHashSize + hashValue] || 0;\n    if (this$static.HASH_ARRAY) {\n        curMatch2 = this$static._hash[hash2Value] || 0;\n        curMatch3 = this$static._hash[1024 + hash3Value] || 0;\n        this$static._hash[hash2Value] = this$static._pos;\n        this$static._hash[1024 + hash3Value] = this$static._pos;\n        if (curMatch2 > matchMinPos) {\n            if (this$static._bufferBase[this$static._bufferOffset + curMatch2] == this$static._bufferBase[cur]) {\n                distances[offset++] = maxLen = 2;\n                distances[offset++] = this$static._pos - curMatch2 - 1;\n            }\n        }\n        if (curMatch3 > matchMinPos) {\n            if (this$static._bufferBase[this$static._bufferOffset + curMatch3] == this$static._bufferBase[cur]) {\n                if (curMatch3 == curMatch2) {\n                    offset -= 2;\n                }\n                distances[offset++] = maxLen = 3;\n                distances[offset++] = this$static._pos - curMatch3 - 1;\n                curMatch2 = curMatch3;\n            }\n        }\n        if (offset != 0 && curMatch2 == curMatch) {\n            offset -= 2;\n            maxLen = 1;\n        }\n    }\n    this$static._hash[this$static.kFixHashSize + hashValue] = this$static._pos;\n    ptr0 = (this$static._cyclicBufferPos << 1) + 1;\n    ptr1 = this$static._cyclicBufferPos << 1;\n    len0 = len1 = this$static.kNumHashDirectBytes;\n    if (this$static.kNumHashDirectBytes != 0) {\n        if (curMatch > matchMinPos) {\n            if (this$static._bufferBase[this$static._bufferOffset + curMatch + this$static.kNumHashDirectBytes] != this$static._bufferBase[cur + this$static.kNumHashDirectBytes]) {\n                distances[offset++] = maxLen = this$static.kNumHashDirectBytes;\n                distances[offset++] = this$static._pos - curMatch - 1;\n            }\n        }\n    }\n    count = this$static._cutValue;\n    while (1) {\n        if (curMatch <= matchMinPos || count == 0) {\n            count -= 1;\n            this$static._son[ptr0] = this$static._son[ptr1] = 0;\n            break;\n        }\n        delta = this$static._pos - curMatch;\n        cyclicPos = (delta <= this$static._cyclicBufferPos?this$static._cyclicBufferPos - delta:this$static._cyclicBufferPos - delta + this$static._cyclicBufferSize) << 1;\n        pby1 = this$static._bufferOffset + curMatch;\n        len = len0 < len1?len0:len1;\n        if (this$static._bufferBase[pby1 + len] == this$static._bufferBase[cur + len]) {\n            while ((len += 1) != lenLimit) {\n                if (this$static._bufferBase[pby1 + len] != this$static._bufferBase[cur + len]) {\n                    break;\n                }\n            }\n            if (maxLen < len) {\n                distances[offset++] = maxLen = len;\n                distances[offset++] = delta - 1;\n                if (len == lenLimit) {\n                this$static._son[ptr1] = this$static._son[cyclicPos];\n                this$static._son[ptr0] = this$static._son[cyclicPos + 1];\n                break;\n                }\n            }\n        }\n        if ((this$static._bufferBase[pby1 + len] & 255) < (this$static._bufferBase[cur + len] & 255)) {\n            this$static._son[ptr1] = curMatch;\n            ptr1 = cyclicPos + 1;\n            curMatch = this$static._son[ptr1];\n            len1 = len;\n        } else {\n            this$static._son[ptr0] = curMatch;\n            ptr0 = cyclicPos;\n            curMatch = this$static._son[ptr0];\n            len0 = len;\n        }\n    }\n    $MovePos_0(this$static);\n    return offset;\n}\n\nfunction $Init_5(this$static) {\n    this$static._bufferOffset = 0;\n    this$static._pos = 0;\n    this$static._streamPos = 0;\n    this$static._streamEndWasReached = 0;\n    $ReadBlock(this$static);\n    this$static._cyclicBufferPos = 0;\n    $ReduceOffsets(this$static, -1);\n}\n\nfunction $MovePos_0(this$static) {\n    var subValue;\n    if ((this$static._cyclicBufferPos += 1) >= this$static._cyclicBufferSize) {\n        this$static._cyclicBufferPos = 0;\n    }\n    $MovePos_1(this$static);\n    if (this$static._pos == 1073741823) {\n        subValue = this$static._pos - this$static._cyclicBufferSize;\n        $NormalizeLinks(this$static._son, this$static._cyclicBufferSize * 2, subValue);\n        $NormalizeLinks(this$static._hash, this$static._hashSizeSum, subValue);\n        $ReduceOffsets(this$static, subValue);\n    }\n}\n\n///NOTE: This is only called after reading one whole gigabyte.\nfunction $NormalizeLinks(items, numItems, subValue) {\n    var i, value;\n    for (i = 0; i < numItems; ++i) {\n        value = items[i] || 0;\n        if (value <= subValue) {\n            value = 0;\n        } else {\n            value -= subValue;\n        }\n        items[i] = value;\n    }\n}\n\nfunction $SetType(this$static, numHashBytes) {\n    this$static.HASH_ARRAY = numHashBytes > 2;\n    if (this$static.HASH_ARRAY) {\n        this$static.kNumHashDirectBytes = 0;\n        this$static.kMinMatchCheck = 4;\n        this$static.kFixHashSize = 66560;\n    } else {\n        this$static.kNumHashDirectBytes = 2;\n        this$static.kMinMatchCheck = 3;\n        this$static.kFixHashSize = 0;\n    }\n}\n\nfunction $Skip(this$static, num) {\n    var count, cur, curMatch, cyclicPos, delta, hash2Value, hash3Value, hashValue, len, len0, len1, lenLimit, matchMinPos, pby1, ptr0, ptr1, temp;\n    do {\n        if (this$static._pos + this$static._matchMaxLen <= this$static._streamPos) {\n            lenLimit = this$static._matchMaxLen;\n        } else {\n            lenLimit = this$static._streamPos - this$static._pos;\n            if (lenLimit < this$static.kMinMatchCheck) {\n                $MovePos_0(this$static);\n                continue;\n            }\n        }\n        matchMinPos = this$static._pos > this$static._cyclicBufferSize?this$static._pos - this$static._cyclicBufferSize:0;\n        cur = this$static._bufferOffset + this$static._pos;\n        if (this$static.HASH_ARRAY) {\n            temp = CrcTable[this$static._bufferBase[cur] & 255] ^ this$static._bufferBase[cur + 1] & 255;\n            hash2Value = temp & 1023;\n            this$static._hash[hash2Value] = this$static._pos;\n            temp ^= (this$static._bufferBase[cur + 2] & 255) << 8;\n            hash3Value = temp & 65535;\n            this$static._hash[1024 + hash3Value] = this$static._pos;\n            hashValue = (temp ^ CrcTable[this$static._bufferBase[cur + 3] & 255] << 5) & this$static._hashMask;\n        } else {\n            hashValue = this$static._bufferBase[cur] & 255 ^ (this$static._bufferBase[cur + 1] & 255) << 8;\n        }\n        curMatch = this$static._hash[this$static.kFixHashSize + hashValue];\n        this$static._hash[this$static.kFixHashSize + hashValue] = this$static._pos;\n        ptr0 = (this$static._cyclicBufferPos << 1) + 1;\n        ptr1 = this$static._cyclicBufferPos << 1;\n        len0 = len1 = this$static.kNumHashDirectBytes;\n        count = this$static._cutValue;\n        while (1) {\n            if (curMatch <= matchMinPos || count == 0) {\n                count -= 1;\n                this$static._son[ptr0] = this$static._son[ptr1] = 0;\n                break;\n            }\n            delta = this$static._pos - curMatch;\n            cyclicPos = (delta <= this$static._cyclicBufferPos?this$static._cyclicBufferPos - delta:this$static._cyclicBufferPos - delta + this$static._cyclicBufferSize) << 1;\n            pby1 = this$static._bufferOffset + curMatch;\n            len = len0 < len1?len0:len1;\n            if (this$static._bufferBase[pby1 + len] == this$static._bufferBase[cur + len]) {\n                while ((len += 1) != lenLimit) {\n                    if (this$static._bufferBase[pby1 + len] != this$static._bufferBase[cur + len]) {\n                        break;\n                    }\n                }\n                if (len == lenLimit) {\n                    this$static._son[ptr1] = this$static._son[cyclicPos];\n                    this$static._son[ptr0] = this$static._son[cyclicPos + 1];\n                    break;\n                }\n            }\n            if ((this$static._bufferBase[pby1 + len] & 255) < (this$static._bufferBase[cur + len] & 255)) {\n                this$static._son[ptr1] = curMatch;\n                ptr1 = cyclicPos + 1;\n                curMatch = this$static._son[ptr1];\n                len1 = len;\n            } else {\n                this$static._son[ptr0] = curMatch;\n                ptr0 = cyclicPos;\n                curMatch = this$static._son[ptr0];\n                len0 = len;\n            }\n        }\n        $MovePos_0(this$static);\n    }\n    while ((num -= 1) != 0);\n}\n\n/** ce */\n/** ds */\nfunction $CopyBlock(this$static, distance, len) {\n    var pos = this$static._pos - distance - 1;\n    if (pos < 0) {\n        pos += this$static._windowSize;\n    }\n    for (; len != 0; len -= 1) {\n        if (pos >= this$static._windowSize) {\n            pos = 0;\n        }\n        this$static._buffer[this$static._pos] = this$static._buffer[pos];\n        this$static._pos += 1;\n        pos += 1;\n        if (this$static._pos >= this$static._windowSize) {\n            $Flush_0(this$static);\n        }\n    }\n}\n\nfunction $Create_5(this$static, windowSize) {\n    if (this$static._buffer == null || this$static._windowSize != windowSize) {\n        this$static._buffer = initDim(windowSize);\n    }\n    this$static._windowSize = windowSize;\n    this$static._pos = 0;\n    this$static._streamPos = 0;\n}\n\nfunction $Flush_0(this$static) {\n    var size = this$static._pos - this$static._streamPos;\n    if (!size) {\n        return;\n    }\n    $write_0(this$static._stream, this$static._buffer, this$static._streamPos, size);\n    if (this$static._pos >= this$static._windowSize) {\n        this$static._pos = 0;\n    }\n    this$static._streamPos = this$static._pos;\n}\n\nfunction $GetByte(this$static, distance) {\n    var pos = this$static._pos - distance - 1;\n    if (pos < 0) {\n        pos += this$static._windowSize;\n    }\n    return this$static._buffer[pos];\n}\n\nfunction $PutByte(this$static, b) {\n    this$static._buffer[this$static._pos] = b;\n    this$static._pos += 1;\n    if (this$static._pos >= this$static._windowSize) {\n        $Flush_0(this$static);\n    }\n}\n\nfunction $ReleaseStream(this$static) {\n    $Flush_0(this$static);\n    this$static._stream = null;\n}\n/** de */\n\nfunction GetLenToPosState(len) {\n    len -= 2;\n    if (len < 4) {\n        return len;\n    }\n    return 3;\n}\n\nfunction StateUpdateChar(index) {\n    if (index < 4) {\n        return 0;\n    }\n    if (index < 10) {\n        return index - 3;\n    }\n    return index - 6;\n}\n\n/** cs */\nfunction $Chunker_0(this$static, encoder) {\n    this$static.encoder = encoder;\n    this$static.decoder = null;\n    this$static.alive = 1;\n    return this$static;\n}\n/** ce */\n/** ds */\nfunction $Chunker(this$static, decoder) {\n    this$static.decoder = decoder;\n    this$static.encoder = null;\n    this$static.alive = 1;\n    return this$static;\n}\n/** de */\n\n/** ds */\nfunction $processChunkDecode(this$static) {\n    if (!this$static.alive) {\n        throw new Error(\"bad state\");\n    }\n    \n    if (this$static.encoder) {\n        throw new Error(\"No encoding\");\n    } else {\n        $processDecoderChunk(this$static);\n    }\n    return this$static.alive;\n}\n\nfunction $processDecoderChunk(this$static) {\n    var result = $CodeOneChunk(this$static.decoder);\n    if (result == -1) {\n        throw new Error(\"corrupted input\");\n    }\n    this$static.inBytesProcessed = N1_longLit;\n    this$static.outBytesProcessed = this$static.decoder.nowPos64;\n    if (result || compare(this$static.decoder.outSize, P0_longLit) >= 0 && compare(this$static.decoder.nowPos64, this$static.decoder.outSize) >= 0) {\n        $Flush_0(this$static.decoder.m_OutWindow);\n        $ReleaseStream(this$static.decoder.m_OutWindow);\n        this$static.decoder.m_RangeDecoder.Stream = null;\n        this$static.alive = 0;\n    }\n}\n/** de */\n/** cs */\nfunction $processChunkEncode(this$static) {\n    if (!this$static.alive) {\n        throw new Error(\"bad state\");\n    }\n    \n    if (this$static.encoder) {\n        $processEncoderChunk(this$static);\n    } else {\n        throw new Error(\"No decoding\");\n    }\n    return this$static.alive;\n}\n\nfunction $processEncoderChunk(this$static) {\n    $CodeOneBlock(this$static.encoder, this$static.encoder.processedInSize, this$static.encoder.processedOutSize, this$static.encoder.finished);\n    this$static.inBytesProcessed = this$static.encoder.processedInSize[0];\n    if (this$static.encoder.finished[0]) {\n        $ReleaseStreams(this$static.encoder);\n        this$static.alive = 0;\n    }\n}\n/** ce */\n\n/** ds */\nfunction $CodeInChunks(this$static, inStream, outStream, outSize) {\n    this$static.m_RangeDecoder.Stream = inStream;\n    $ReleaseStream(this$static.m_OutWindow);\n    this$static.m_OutWindow._stream = outStream;\n    $Init_1(this$static);\n    this$static.state = 0;\n    this$static.rep0 = 0;\n    this$static.rep1 = 0;\n    this$static.rep2 = 0;\n    this$static.rep3 = 0;\n    this$static.outSize = outSize;\n    this$static.nowPos64 = P0_longLit;\n    this$static.prevByte = 0;\n    return $Chunker({}, this$static);\n}\n\nfunction $CodeOneChunk(this$static) {\n    var decoder2, distance, len, numDirectBits, posSlot, posState;\n    posState = lowBits_0(this$static.nowPos64) & this$static.m_PosStateMask;\n    if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsMatchDecoders, (this$static.state << 4) + posState)) {\n        decoder2 = $GetDecoder(this$static.m_LiteralDecoder, lowBits_0(this$static.nowPos64), this$static.prevByte);\n        if (this$static.state < 7) {\n            this$static.prevByte = $DecodeNormal(decoder2, this$static.m_RangeDecoder);\n        } else {\n            this$static.prevByte = $DecodeWithMatchByte(decoder2, this$static.m_RangeDecoder, $GetByte(this$static.m_OutWindow, this$static.rep0));\n        }\n        $PutByte(this$static.m_OutWindow, this$static.prevByte);\n        this$static.state = StateUpdateChar(this$static.state);\n        this$static.nowPos64 = add(this$static.nowPos64, P1_longLit);\n    } else {\n        if ($DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRepDecoders, this$static.state)) {\n            len = 0;\n            if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRepG0Decoders, this$static.state)) {\n                if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRep0LongDecoders, (this$static.state << 4) + posState)) {\n                    this$static.state = this$static.state < 7?9:11;\n                    len = 1;\n                }\n            } else {\n                if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRepG1Decoders, this$static.state)) {\n                    distance = this$static.rep1;\n                } else {\n                    if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRepG2Decoders, this$static.state)) {\n                        distance = this$static.rep2;\n                    } else {\n                        distance = this$static.rep3;\n                        this$static.rep3 = this$static.rep2;\n                    }\n                    this$static.rep2 = this$static.rep1;\n                }\n                this$static.rep1 = this$static.rep0;\n                this$static.rep0 = distance;\n            }\n            if (!len) {\n                len = $Decode(this$static.m_RepLenDecoder, this$static.m_RangeDecoder, posState) + 2;\n                this$static.state = this$static.state < 7?8:11;\n            }\n        } else {\n            this$static.rep3 = this$static.rep2;\n            this$static.rep2 = this$static.rep1;\n            this$static.rep1 = this$static.rep0;\n            len = 2 + $Decode(this$static.m_LenDecoder, this$static.m_RangeDecoder, posState);\n            this$static.state = this$static.state < 7?7:10;\n            posSlot = $Decode_0(this$static.m_PosSlotDecoder[GetLenToPosState(len)], this$static.m_RangeDecoder);\n            if (posSlot >= 4) {\n                numDirectBits = (posSlot >> 1) - 1;\n                this$static.rep0 = (2 | posSlot & 1) << numDirectBits;\n                if (posSlot < 14) {\n                    this$static.rep0 += ReverseDecode(this$static.m_PosDecoders, this$static.rep0 - posSlot - 1, this$static.m_RangeDecoder, numDirectBits);\n                } else {\n                    this$static.rep0 += $DecodeDirectBits(this$static.m_RangeDecoder, numDirectBits - 4) << 4;\n                    this$static.rep0 += $ReverseDecode(this$static.m_PosAlignDecoder, this$static.m_RangeDecoder);\n                    if (this$static.rep0 < 0) {\n                        if (this$static.rep0 == -1) {\n                            return 1;\n                        }\n                        return -1;\n                    }\n                }\n            } else \n                this$static.rep0 = posSlot;\n        }\n        if (compare(fromInt(this$static.rep0), this$static.nowPos64) >= 0 || this$static.rep0 >= this$static.m_DictionarySizeCheck) {\n            return -1;\n        }\n        $CopyBlock(this$static.m_OutWindow, this$static.rep0, len);\n        this$static.nowPos64 = add(this$static.nowPos64, fromInt(len));\n        this$static.prevByte = $GetByte(this$static.m_OutWindow, 0);\n    }\n    return 0;\n}\n\nfunction $Decoder(this$static) {\n    this$static.m_OutWindow = {};\n    this$static.m_RangeDecoder = {};\n    this$static.m_IsMatchDecoders = initDim(192);\n    this$static.m_IsRepDecoders = initDim(12);\n    this$static.m_IsRepG0Decoders = initDim(12);\n    this$static.m_IsRepG1Decoders = initDim(12);\n    this$static.m_IsRepG2Decoders = initDim(12);\n    this$static.m_IsRep0LongDecoders = initDim(192);\n    this$static.m_PosSlotDecoder = initDim(4);\n    this$static.m_PosDecoders = initDim(114);\n    this$static.m_PosAlignDecoder = $BitTreeDecoder({}, 4);\n    this$static.m_LenDecoder = $Decoder$LenDecoder({});\n    this$static.m_RepLenDecoder = $Decoder$LenDecoder({});\n    this$static.m_LiteralDecoder = {};\n    for (var i = 0; i < 4; ++i) {\n        this$static.m_PosSlotDecoder[i] = $BitTreeDecoder({}, 6);\n    }\n    return this$static;\n}\n\nfunction $Init_1(this$static) {\n    this$static.m_OutWindow._streamPos = 0;\n    this$static.m_OutWindow._pos = 0;\n    InitBitModels(this$static.m_IsMatchDecoders);\n    InitBitModels(this$static.m_IsRep0LongDecoders);\n    InitBitModels(this$static.m_IsRepDecoders);\n    InitBitModels(this$static.m_IsRepG0Decoders);\n    InitBitModels(this$static.m_IsRepG1Decoders);\n    InitBitModels(this$static.m_IsRepG2Decoders);\n    InitBitModels(this$static.m_PosDecoders);\n    $Init_0(this$static.m_LiteralDecoder);\n    for (var i = 0; i < 4; ++i) {\n        InitBitModels(this$static.m_PosSlotDecoder[i].Models);\n    }\n    $Init(this$static.m_LenDecoder);\n    $Init(this$static.m_RepLenDecoder);\n    InitBitModels(this$static.m_PosAlignDecoder.Models);\n    $Init_8(this$static.m_RangeDecoder);\n}\n\nfunction $SetDecoderProperties(this$static, properties) {\n    var dictionarySize, i, lc, lp, pb, remainder, val;\n    if (properties.length < 5)\n        return 0;\n    val = properties[0] & 255;\n    lc = val % 9;\n    remainder = ~~(val / 9);\n    lp = remainder % 5;\n    pb = ~~(remainder / 5);\n    dictionarySize = 0;\n    for (i = 0; i < 4; ++i) {\n        dictionarySize += (properties[1 + i] & 255) << i * 8;\n    }\n    ///NOTE: If the input is bad, it might call for an insanely large dictionary size, which would crash the script.\n    if (dictionarySize > 99999999 || !$SetLcLpPb(this$static, lc, lp, pb)) {\n        return 0;\n    }\n    return $SetDictionarySize(this$static, dictionarySize);\n}\n\nfunction $SetDictionarySize(this$static, dictionarySize) {\n    if (dictionarySize < 0) {\n        return 0;\n    }\n    if (this$static.m_DictionarySize != dictionarySize) {\n        this$static.m_DictionarySize = dictionarySize;\n        this$static.m_DictionarySizeCheck = Math.max(this$static.m_DictionarySize, 1);\n        $Create_5(this$static.m_OutWindow, Math.max(this$static.m_DictionarySizeCheck, 4096));\n    }\n    return 1;\n}\n\nfunction $SetLcLpPb(this$static, lc, lp, pb) {\n    if (lc > 8 || lp > 4 || pb > 4) {\n        return 0;\n    }\n    $Create_0(this$static.m_LiteralDecoder, lp, lc);\n    var numPosStates = 1 << pb;\n    $Create(this$static.m_LenDecoder, numPosStates);\n    $Create(this$static.m_RepLenDecoder, numPosStates);\n    this$static.m_PosStateMask = numPosStates - 1;\n    return 1;\n}\n\nfunction $Create(this$static, numPosStates) {\n    for (; this$static.m_NumPosStates < numPosStates; this$static.m_NumPosStates += 1) {\n        this$static.m_LowCoder[this$static.m_NumPosStates] = $BitTreeDecoder({}, 3);\n        this$static.m_MidCoder[this$static.m_NumPosStates] = $BitTreeDecoder({}, 3);\n    }\n}\n\nfunction $Decode(this$static, rangeDecoder, posState) {\n    if (!$DecodeBit(rangeDecoder, this$static.m_Choice, 0)) {\n        return $Decode_0(this$static.m_LowCoder[posState], rangeDecoder);\n    }\n    var symbol = 8;\n    if (!$DecodeBit(rangeDecoder, this$static.m_Choice, 1)) {\n        symbol += $Decode_0(this$static.m_MidCoder[posState], rangeDecoder);\n    } else {\n        symbol += 8 + $Decode_0(this$static.m_HighCoder, rangeDecoder);\n    }\n    return symbol;\n}\n\nfunction $Decoder$LenDecoder(this$static) {\n    this$static.m_Choice = initDim(2);\n    this$static.m_LowCoder = initDim(16);\n    this$static.m_MidCoder = initDim(16);\n    this$static.m_HighCoder = $BitTreeDecoder({}, 8);\n    this$static.m_NumPosStates = 0;\n    return this$static;\n}\n\nfunction $Init(this$static) {\n    InitBitModels(this$static.m_Choice);\n    for (var posState = 0; posState < this$static.m_NumPosStates; ++posState) {\n        InitBitModels(this$static.m_LowCoder[posState].Models);\n        InitBitModels(this$static.m_MidCoder[posState].Models);\n    }\n    InitBitModels(this$static.m_HighCoder.Models);\n}\n\n\nfunction $Create_0(this$static, numPosBits, numPrevBits) {\n    var i, numStates;\n    if (this$static.m_Coders != null && this$static.m_NumPrevBits == numPrevBits && this$static.m_NumPosBits == numPosBits)\n        return;\n    this$static.m_NumPosBits = numPosBits;\n    this$static.m_PosMask = (1 << numPosBits) - 1;\n    this$static.m_NumPrevBits = numPrevBits;\n    numStates = 1 << this$static.m_NumPrevBits + this$static.m_NumPosBits;\n    this$static.m_Coders = initDim(numStates);\n    for (i = 0; i < numStates; ++i)\n        this$static.m_Coders[i] = $Decoder$LiteralDecoder$Decoder2({});\n}\n\nfunction $GetDecoder(this$static, pos, prevByte) {\n    return this$static.m_Coders[((pos & this$static.m_PosMask) << this$static.m_NumPrevBits) + ((prevByte & 255) >>> 8 - this$static.m_NumPrevBits)];\n}\n\nfunction $Init_0(this$static) {\n    var i, numStates;\n    numStates = 1 << this$static.m_NumPrevBits + this$static.m_NumPosBits;\n    for (i = 0; i < numStates; ++i) {\n        InitBitModels(this$static.m_Coders[i].m_Decoders);\n    }\n}\n\n\nfunction $DecodeNormal(this$static, rangeDecoder) {\n    var symbol = 1;\n    do {\n        symbol = symbol << 1 | $DecodeBit(rangeDecoder, this$static.m_Decoders, symbol);\n    } while (symbol < 256);\n    return symbol << 24 >> 24;\n}\n\nfunction $DecodeWithMatchByte(this$static, rangeDecoder, matchByte) {\n    var bit, matchBit, symbol = 1;\n    do {\n        matchBit = matchByte >> 7 & 1;\n        matchByte <<= 1;\n        bit = $DecodeBit(rangeDecoder, this$static.m_Decoders, (1 + matchBit << 8) + symbol);\n        symbol = symbol << 1 | bit;\n        if (matchBit != bit) {\n            while (symbol < 256) {\n                symbol = symbol << 1 | $DecodeBit(rangeDecoder, this$static.m_Decoders, symbol);\n            }\n        break;\n        }\n    } while (symbol < 256);\n    return symbol << 24 >> 24;\n}\n\nfunction $Decoder$LiteralDecoder$Decoder2(this$static) {\n    this$static.m_Decoders = initDim(768);\n    return this$static;\n}\n\n/** de */\n/** cs */\nvar g_FastPos = (function () {\n    var j, k, slotFast, c = 2, g_FastPos = [0, 1];\n    for (slotFast = 2; slotFast < 22; ++slotFast) {\n        //k = 1 << (slotFast >> 1) - 1;\n        var s = slotFast;\n        s >>= 1;\n        s -= 1;\n        k = 1;\n        k <<= s;\n        for (j = 0; j < k; ++j , ++c)\n            g_FastPos[c] = slotFast << 24 >> 24;\n    }\n    return g_FastPos;\n}());\n\nfunction $Backward(this$static, cur) {\n    var backCur, backMem, posMem, posPrev;\n    this$static._optimumEndIndex = cur;\n    posMem = this$static._optimum[cur].PosPrev;\n    backMem = this$static._optimum[cur].BackPrev;\n    do {\n        if (this$static._optimum[cur].Prev1IsChar) {\n            $MakeAsChar(this$static._optimum[posMem]);\n            this$static._optimum[posMem].PosPrev = posMem - 1;\n            if (this$static._optimum[cur].Prev2) {\n                this$static._optimum[posMem - 1].Prev1IsChar = 0;\n                this$static._optimum[posMem - 1].PosPrev = this$static._optimum[cur].PosPrev2;\n                this$static._optimum[posMem - 1].BackPrev = this$static._optimum[cur].BackPrev2;\n            }\n        }\n        posPrev = posMem;\n        backCur = backMem;\n        backMem = this$static._optimum[posPrev].BackPrev;\n        posMem = this$static._optimum[posPrev].PosPrev;\n        this$static._optimum[posPrev].BackPrev = backCur;\n        this$static._optimum[posPrev].PosPrev = cur;\n        cur = posPrev;\n    } while (cur > 0);\n    this$static.backRes = this$static._optimum[0].BackPrev;\n    this$static._optimumCurrentIndex = this$static._optimum[0].PosPrev;\n    return this$static._optimumCurrentIndex;\n}\n\nfunction $BaseInit(this$static) {\n    this$static._state = 0;\n    this$static._previousByte = 0;\n    for (var i = 0; i < 4; ++i) {\n        this$static._repDistances[i] = 0;\n    }\n}\n\nfunction $CodeOneBlock(this$static, inSize, outSize, finished) {\n    var baseVal, complexState, curByte, distance, footerBits, i, len, lenToPosState, matchByte, pos, posReduced, posSlot, posState, progressPosValuePrev, subCoder;\n    inSize[0] = P0_longLit;\n    outSize[0] = P0_longLit;\n    finished[0] = 1;\n    if (this$static._inStream) {\n        this$static._matchFinder._stream = this$static._inStream;\n        $Init_5(this$static._matchFinder);\n        this$static._needReleaseMFStream = 1;\n        this$static._inStream = null;\n    }\n    if (this$static._finished) {\n        return;\n    }\n    this$static._finished = 1;\n    progressPosValuePrev = this$static.nowPos64;\n    if (eq(this$static.nowPos64, P0_longLit)) {\n        if (!$GetNumAvailableBytes(this$static._matchFinder)) {\n            $Flush(this$static, lowBits_0(this$static.nowPos64));\n            return;\n        }\n        $ReadMatchDistances(this$static);\n        posState = lowBits_0(this$static.nowPos64) & this$static._posStateMask;\n        $Encode_3(this$static._rangeEncoder, this$static._isMatch, (this$static._state << 4) + posState, 0);\n        this$static._state = StateUpdateChar(this$static._state);\n        curByte = $GetIndexByte(this$static._matchFinder, -this$static._additionalOffset);\n        $Encode_1($GetSubCoder(this$static._literalEncoder, lowBits_0(this$static.nowPos64), this$static._previousByte), this$static._rangeEncoder, curByte);\n        this$static._previousByte = curByte;\n        this$static._additionalOffset -= 1;\n        this$static.nowPos64 = add(this$static.nowPos64, P1_longLit);\n    }\n    if (!$GetNumAvailableBytes(this$static._matchFinder)) {\n        $Flush(this$static, lowBits_0(this$static.nowPos64));\n        return;\n    }\n    while (1) {\n        len = $GetOptimum(this$static, lowBits_0(this$static.nowPos64));\n        pos = this$static.backRes;\n        posState = lowBits_0(this$static.nowPos64) & this$static._posStateMask;\n        complexState = (this$static._state << 4) + posState;\n        if (len == 1 && pos == -1) {\n            $Encode_3(this$static._rangeEncoder, this$static._isMatch, complexState, 0);\n            curByte = $GetIndexByte(this$static._matchFinder, -this$static._additionalOffset);\n            subCoder = $GetSubCoder(this$static._literalEncoder, lowBits_0(this$static.nowPos64), this$static._previousByte);\n            if (this$static._state < 7) {\n                $Encode_1(subCoder, this$static._rangeEncoder, curByte);\n            } else {\n                matchByte = $GetIndexByte(this$static._matchFinder, -this$static._repDistances[0] - 1 - this$static._additionalOffset);\n                $EncodeMatched(subCoder, this$static._rangeEncoder, matchByte, curByte);\n            }\n            this$static._previousByte = curByte;\n            this$static._state = StateUpdateChar(this$static._state);\n        } else {\n            $Encode_3(this$static._rangeEncoder, this$static._isMatch, complexState, 1);\n            if (pos < 4) {\n                $Encode_3(this$static._rangeEncoder, this$static._isRep, this$static._state, 1);\n                if (!pos) {\n                    $Encode_3(this$static._rangeEncoder, this$static._isRepG0, this$static._state, 0);\n                    if (len == 1) {\n                        $Encode_3(this$static._rangeEncoder, this$static._isRep0Long, complexState, 0);\n                    } else {\n                        $Encode_3(this$static._rangeEncoder, this$static._isRep0Long, complexState, 1);\n                    }\n                } else {\n                    $Encode_3(this$static._rangeEncoder, this$static._isRepG0, this$static._state, 1);\n                    if (pos == 1) {\n                        $Encode_3(this$static._rangeEncoder, this$static._isRepG1, this$static._state, 0);\n                    } else {\n                        $Encode_3(this$static._rangeEncoder, this$static._isRepG1, this$static._state, 1);\n                        $Encode_3(this$static._rangeEncoder, this$static._isRepG2, this$static._state, pos - 2);\n                    }\n                }\n                if (len == 1) {\n                    this$static._state = this$static._state < 7?9:11;\n                } else {\n                    $Encode_0(this$static._repMatchLenEncoder, this$static._rangeEncoder, len - 2, posState);\n                    this$static._state = this$static._state < 7?8:11;\n                }\n                distance = this$static._repDistances[pos];\n                if (pos != 0) {\n                    for (var i = pos; i >= 1; --i) {\n                        this$static._repDistances[i] = this$static._repDistances[i - 1];\n                    }\n                    this$static._repDistances[0] = distance;\n                }\n            } else {\n                $Encode_3(this$static._rangeEncoder, this$static._isRep, this$static._state, 0);\n                this$static._state = this$static._state < 7?7:10;\n                $Encode_0(this$static._lenEncoder, this$static._rangeEncoder, len - 2, posState);\n                pos -= 4;\n                posSlot = GetPosSlot(pos);\n                lenToPosState = GetLenToPosState(len);\n                $Encode_2(this$static._posSlotEncoder[lenToPosState], this$static._rangeEncoder, posSlot);\n                if (posSlot >= 4) {\n                    footerBits = (posSlot >> 1) - 1;\n                    baseVal = (2 | posSlot & 1) << footerBits;\n                    posReduced = pos - baseVal;\n                    if (posSlot < 14) {\n                        ReverseEncode(this$static._posEncoders, baseVal - posSlot - 1, this$static._rangeEncoder, footerBits, posReduced);\n                    } else {\n                        $EncodeDirectBits(this$static._rangeEncoder, posReduced >> 4, footerBits - 4);\n                        $ReverseEncode(this$static._posAlignEncoder, this$static._rangeEncoder, posReduced & 15);\n                        this$static._alignPriceCount += 1;\n                    }\n                }\n                distance = pos;\n                for (var i = 3; i >= 1; --i) {\n                    this$static._repDistances[i] = this$static._repDistances[i - 1];\n                }\n                this$static._repDistances[0] = distance;\n                this$static._matchPriceCount += 1;\n            }\n            this$static._previousByte = $GetIndexByte(this$static._matchFinder, len - 1 - this$static._additionalOffset);\n        }\n        this$static._additionalOffset -= len;\n        this$static.nowPos64 = add(this$static.nowPos64, fromInt(len));\n        if (!this$static._additionalOffset) {\n            if (this$static._matchPriceCount >= 128) {\n                $FillDistancesPrices(this$static);\n            }\n            if (this$static._alignPriceCount >= 16) {\n                $FillAlignPrices(this$static);\n            }\n            inSize[0] = this$static.nowPos64;\n            outSize[0] = $GetProcessedSizeAdd(this$static._rangeEncoder);\n            if (!$GetNumAvailableBytes(this$static._matchFinder)) {\n                $Flush(this$static, lowBits_0(this$static.nowPos64));\n                return;\n            }\n            if (compare(sub(this$static.nowPos64, progressPosValuePrev), [4096, 0]) >= 0) {\n                this$static._finished = 0;\n                finished[0] = 0;\n                return;\n            }\n        }\n    }\n}\n\nfunction $Create_2(this$static) {\n    var bt, numHashBytes;\n    if (!this$static._matchFinder) {\n        bt = {};\n        numHashBytes = 4;\n        if (!this$static._matchFinderType) {\n            numHashBytes = 2;\n        }\n        $SetType(bt, numHashBytes);\n        this$static._matchFinder = bt;\n    }\n    $Create_1(this$static._literalEncoder, this$static._numLiteralPosStateBits, this$static._numLiteralContextBits);\n    if (this$static._dictionarySize == this$static._dictionarySizePrev && this$static._numFastBytesPrev == this$static._numFastBytes) {\n        return;\n    }\n    $Create_3(this$static._matchFinder, this$static._dictionarySize, 4096, this$static._numFastBytes, 274);\n    this$static._dictionarySizePrev = this$static._dictionarySize;\n    this$static._numFastBytesPrev = this$static._numFastBytes;\n}\n\nfunction $Encoder(this$static) {\n    var i;\n    this$static._repDistances = initDim(4);\n    this$static._optimum = [];\n    this$static._rangeEncoder = {};\n    this$static._isMatch = initDim(192);\n    this$static._isRep = initDim(12);\n    this$static._isRepG0 = initDim(12);\n    this$static._isRepG1 = initDim(12);\n    this$static._isRepG2 = initDim(12);\n    this$static._isRep0Long = initDim(192);\n    this$static._posSlotEncoder = [];\n    this$static._posEncoders = initDim(114);\n    this$static._posAlignEncoder = $BitTreeEncoder({}, 4);\n    this$static._lenEncoder = $Encoder$LenPriceTableEncoder({});\n    this$static._repMatchLenEncoder = $Encoder$LenPriceTableEncoder({});\n    this$static._literalEncoder = {};\n    this$static._matchDistances = [];\n    this$static._posSlotPrices = [];\n    this$static._distancesPrices = [];\n    this$static._alignPrices = initDim(16);\n    this$static.reps = initDim(4);\n    this$static.repLens = initDim(4);\n    this$static.processedInSize = [P0_longLit];\n    this$static.processedOutSize = [P0_longLit];\n    this$static.finished = [0];\n    this$static.properties = initDim(5);\n    this$static.tempPrices = initDim(128);\n    this$static._longestMatchLength = 0;\n    this$static._matchFinderType = 1;\n    this$static._numDistancePairs = 0;\n    this$static._numFastBytesPrev = -1;\n    this$static.backRes = 0;\n    for (i = 0; i < 4096; ++i) {\n        this$static._optimum[i] = {};\n    }\n    for (i = 0; i < 4; ++i) {\n        this$static._posSlotEncoder[i] = $BitTreeEncoder({}, 6);\n    }\n    return this$static;\n}\n\nfunction $FillAlignPrices(this$static) {\n    for (var i = 0; i < 16; ++i) {\n        this$static._alignPrices[i] = $ReverseGetPrice(this$static._posAlignEncoder, i);\n    }\n    this$static._alignPriceCount = 0;\n}\n\nfunction $FillDistancesPrices(this$static) {\n    var baseVal, encoder, footerBits, i, lenToPosState, posSlot, st, st2;\n    for (i = 4; i < 128; ++i) {\n        posSlot = GetPosSlot(i);\n        footerBits = (posSlot >> 1) - 1;\n        baseVal = (2 | posSlot & 1) << footerBits;\n        this$static.tempPrices[i] = ReverseGetPrice(this$static._posEncoders, baseVal - posSlot - 1, footerBits, i - baseVal);\n    }\n    for (lenToPosState = 0; lenToPosState < 4; ++lenToPosState) {\n        encoder = this$static._posSlotEncoder[lenToPosState];\n        st = lenToPosState << 6;\n        for (posSlot = 0; posSlot < this$static._distTableSize; posSlot += 1) {\n            this$static._posSlotPrices[st + posSlot] = $GetPrice_1(encoder, posSlot);\n        }\n        for (posSlot = 14; posSlot < this$static._distTableSize; posSlot += 1) {\n            this$static._posSlotPrices[st + posSlot] += (posSlot >> 1) - 1 - 4 << 6;\n        }\n        st2 = lenToPosState * 128;\n        for (i = 0; i < 4; ++i) {\n            this$static._distancesPrices[st2 + i] = this$static._posSlotPrices[st + i];\n        }\n        for (; i < 128; ++i) {\n            this$static._distancesPrices[st2 + i] = this$static._posSlotPrices[st + GetPosSlot(i)] + this$static.tempPrices[i];\n        }\n    }\n    this$static._matchPriceCount = 0;\n}\n\nfunction $Flush(this$static, nowPos) {\n    $ReleaseMFStream(this$static);\n    $WriteEndMarker(this$static, nowPos & this$static._posStateMask);\n    for (var i = 0; i < 5; ++i) {\n        $ShiftLow(this$static._rangeEncoder);\n    }\n}\n\nfunction $GetOptimum(this$static, position) {\n    var cur, curAnd1Price, curAndLenCharPrice, curAndLenPrice, curBack, curPrice, currentByte, distance, i, len, lenEnd, lenMain, lenRes, lenTest, lenTest2, lenTestTemp, matchByte, matchPrice, newLen, nextIsChar, nextMatchPrice, nextOptimum, nextRepMatchPrice, normalMatchPrice, numAvailableBytes, numAvailableBytesFull, numDistancePairs, offs, offset, opt, optimum, pos, posPrev, posState, posStateNext, price_4, repIndex, repLen, repMatchPrice, repMaxIndex, shortRepPrice, startLen, state, state2, t, price, price_0, price_1, price_2, price_3;\n    if (this$static._optimumEndIndex != this$static._optimumCurrentIndex) {\n        lenRes = this$static._optimum[this$static._optimumCurrentIndex].PosPrev - this$static._optimumCurrentIndex;\n        this$static.backRes = this$static._optimum[this$static._optimumCurrentIndex].BackPrev;\n        this$static._optimumCurrentIndex = this$static._optimum[this$static._optimumCurrentIndex].PosPrev;\n        return lenRes;\n    }\n    this$static._optimumCurrentIndex = this$static._optimumEndIndex = 0;\n    if (this$static._longestMatchWasFound) {\n        lenMain = this$static._longestMatchLength;\n        this$static._longestMatchWasFound = 0;\n    } else {\n        lenMain = $ReadMatchDistances(this$static);\n    }\n    numDistancePairs = this$static._numDistancePairs;\n    numAvailableBytes = $GetNumAvailableBytes(this$static._matchFinder) + 1;\n    if (numAvailableBytes < 2) {\n        this$static.backRes = -1;\n        return 1;\n    }\n    if (numAvailableBytes > 273) {\n        numAvailableBytes = 273;\n    }\n    repMaxIndex = 0;\n    for (i = 0; i < 4; ++i) {\n        this$static.reps[i] = this$static._repDistances[i];\n        this$static.repLens[i] = $GetMatchLen(this$static._matchFinder, -1, this$static.reps[i], 273);\n        if (this$static.repLens[i] > this$static.repLens[repMaxIndex]) {\n            repMaxIndex = i;\n        }\n    }\n    if (this$static.repLens[repMaxIndex] >= this$static._numFastBytes) {\n        this$static.backRes = repMaxIndex;\n        lenRes = this$static.repLens[repMaxIndex];\n        $MovePos(this$static, lenRes - 1);\n        return lenRes;\n    }\n    if (lenMain >= this$static._numFastBytes) {\n        this$static.backRes = this$static._matchDistances[numDistancePairs - 1] + 4;\n        $MovePos(this$static, lenMain - 1);\n        return lenMain;\n    }\n    currentByte = $GetIndexByte(this$static._matchFinder, -1);\n    matchByte = $GetIndexByte(this$static._matchFinder, -this$static._repDistances[0] - 1 - 1);\n    if (lenMain < 2 && currentByte != matchByte && this$static.repLens[repMaxIndex] < 2) {\n        this$static.backRes = -1;\n        return 1;\n    }\n    this$static._optimum[0].State = this$static._state;\n    posState = position & this$static._posStateMask;\n    this$static._optimum[1].Price = ProbPrices[this$static._isMatch[(this$static._state << 4) + posState] >>> 2] + $GetPrice_0($GetSubCoder(this$static._literalEncoder, position, this$static._previousByte), this$static._state >= 7, matchByte, currentByte);\n    $MakeAsChar(this$static._optimum[1]);\n    matchPrice = ProbPrices[2048 - this$static._isMatch[(this$static._state << 4) + posState] >>> 2];\n    repMatchPrice = matchPrice + ProbPrices[2048 - this$static._isRep[this$static._state] >>> 2];\n    if (matchByte == currentByte) {\n        shortRepPrice = repMatchPrice + $GetRepLen1Price(this$static, this$static._state, posState);\n        if (shortRepPrice < this$static._optimum[1].Price) {\n            this$static._optimum[1].Price = shortRepPrice;\n            $MakeAsShortRep(this$static._optimum[1]);\n        }\n    }\n    lenEnd = lenMain >= this$static.repLens[repMaxIndex]?lenMain:this$static.repLens[repMaxIndex];\n    if (lenEnd < 2) {\n        this$static.backRes = this$static._optimum[1].BackPrev;\n        return 1;\n    }\n    this$static._optimum[1].PosPrev = 0;\n    this$static._optimum[0].Backs0 = this$static.reps[0];\n    this$static._optimum[0].Backs1 = this$static.reps[1];\n    this$static._optimum[0].Backs2 = this$static.reps[2];\n    this$static._optimum[0].Backs3 = this$static.reps[3];\n    len = lenEnd;\n    do {\n        this$static._optimum[len].Price = 268435455;\n        len -= 1;\n    } while (len >= 2);\n    for (i = 0; i < 4; ++i) {\n        repLen = this$static.repLens[i];\n        if (repLen < 2) {\n            continue;\n        }\n        price_4 = repMatchPrice + $GetPureRepPrice(this$static, i, this$static._state, posState);\n        do {\n            curAndLenPrice = price_4 + $GetPrice(this$static._repMatchLenEncoder, repLen - 2, posState);\n            optimum = this$static._optimum[repLen];\n            if (curAndLenPrice < optimum.Price) {\n                optimum.Price = curAndLenPrice;\n                optimum.PosPrev = 0;\n                optimum.BackPrev = i;\n                optimum.Prev1IsChar = 0;\n            }\n        } while ((repLen -= 1) >= 2);\n    }\n    normalMatchPrice = matchPrice + ProbPrices[this$static._isRep[this$static._state] >>> 2];\n    len = this$static.repLens[0] >= 2?this$static.repLens[0] + 1:2;\n    if (len <= lenMain) {\n        offs = 0;\n        while (len > this$static._matchDistances[offs]) {\n            offs += 2;\n        }\n        for (;; len += 1) {\n            distance = this$static._matchDistances[offs + 1];\n            curAndLenPrice = normalMatchPrice + $GetPosLenPrice(this$static, distance, len, posState);\n            optimum = this$static._optimum[len];\n            if (curAndLenPrice < optimum.Price) {\n                optimum.Price = curAndLenPrice;\n                optimum.PosPrev = 0;\n                optimum.BackPrev = distance + 4;\n                optimum.Prev1IsChar = 0;\n            }\n            if (len == this$static._matchDistances[offs]) {\n                offs += 2;\n                if (offs == numDistancePairs) {\n                    break;\n                }\n            }\n        }\n    }\n    cur = 0;\n    while (1) {\n        ++cur;\n        if (cur == lenEnd) {\n            return $Backward(this$static, cur);\n        }\n        newLen = $ReadMatchDistances(this$static);\n        numDistancePairs = this$static._numDistancePairs;\n        if (newLen >= this$static._numFastBytes) {\n            this$static._longestMatchLength = newLen;\n            this$static._longestMatchWasFound = 1;\n            return $Backward(this$static, cur);\n        }\n        position += 1;\n        posPrev = this$static._optimum[cur].PosPrev;\n        if (this$static._optimum[cur].Prev1IsChar) {\n            posPrev -= 1;\n            if (this$static._optimum[cur].Prev2) {\n                state = this$static._optimum[this$static._optimum[cur].PosPrev2].State;\n                if (this$static._optimum[cur].BackPrev2 < 4) {\n                    state = (state < 7) ? 8 : 11;\n                } else {\n                    state = (state < 7) ? 7 : 10;\n                }\n            } else {\n                state = this$static._optimum[posPrev].State;\n            }\n            state = StateUpdateChar(state);\n        } else {\n            state = this$static._optimum[posPrev].State;\n        }\n        if (posPrev == cur - 1) {\n            if (!this$static._optimum[cur].BackPrev) {\n                state = state < 7?9:11;\n            } else {\n                state = StateUpdateChar(state);\n            }\n        } else {\n            if (this$static._optimum[cur].Prev1IsChar && this$static._optimum[cur].Prev2) {\n                posPrev = this$static._optimum[cur].PosPrev2;\n                pos = this$static._optimum[cur].BackPrev2;\n                state = state < 7?8:11;\n            } else {\n                pos = this$static._optimum[cur].BackPrev;\n                if (pos < 4) {\n                    state = state < 7?8:11;\n                } else {\n                    state = state < 7?7:10;\n                }\n            }\n            opt = this$static._optimum[posPrev];\n            if (pos < 4) {\n                if (!pos) {\n                    this$static.reps[0] = opt.Backs0;\n                    this$static.reps[1] = opt.Backs1;\n                    this$static.reps[2] = opt.Backs2;\n                    this$static.reps[3] = opt.Backs3;\n                } else if (pos == 1) {\n                    this$static.reps[0] = opt.Backs1;\n                    this$static.reps[1] = opt.Backs0;\n                    this$static.reps[2] = opt.Backs2;\n                    this$static.reps[3] = opt.Backs3;\n                } else if (pos == 2) {\n                    this$static.reps[0] = opt.Backs2;\n                    this$static.reps[1] = opt.Backs0;\n                    this$static.reps[2] = opt.Backs1;\n                    this$static.reps[3] = opt.Backs3;\n                } else {\n                    this$static.reps[0] = opt.Backs3;\n                    this$static.reps[1] = opt.Backs0;\n                    this$static.reps[2] = opt.Backs1;\n                    this$static.reps[3] = opt.Backs2;\n                }\n            } else {\n                this$static.reps[0] = pos - 4;\n                this$static.reps[1] = opt.Backs0;\n                this$static.reps[2] = opt.Backs1;\n                this$static.reps[3] = opt.Backs2;\n            }\n        }\n        this$static._optimum[cur].State = state;\n        this$static._optimum[cur].Backs0 = this$static.reps[0];\n        this$static._optimum[cur].Backs1 = this$static.reps[1];\n        this$static._optimum[cur].Backs2 = this$static.reps[2];\n        this$static._optimum[cur].Backs3 = this$static.reps[3];\n        curPrice = this$static._optimum[cur].Price;\n        currentByte = $GetIndexByte(this$static._matchFinder, -1);\n        matchByte = $GetIndexByte(this$static._matchFinder, -this$static.reps[0] - 1 - 1);\n        posState = position & this$static._posStateMask;\n        curAnd1Price = curPrice + ProbPrices[this$static._isMatch[(state << 4) + posState] >>> 2] + $GetPrice_0($GetSubCoder(this$static._literalEncoder, position, $GetIndexByte(this$static._matchFinder, -2)), state >= 7, matchByte, currentByte);\n        nextOptimum = this$static._optimum[cur + 1];\n        nextIsChar = 0;\n        if (curAnd1Price < nextOptimum.Price) {\n            nextOptimum.Price = curAnd1Price;\n            nextOptimum.PosPrev = cur;\n            nextOptimum.BackPrev = -1;\n            nextOptimum.Prev1IsChar = 0;\n            nextIsChar = 1;\n        }\n        matchPrice = curPrice + ProbPrices[2048 - this$static._isMatch[(state << 4) + posState] >>> 2];\n        repMatchPrice = matchPrice + ProbPrices[2048 - this$static._isRep[state] >>> 2];\n        if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && !nextOptimum.BackPrev)) {\n            shortRepPrice = repMatchPrice + (ProbPrices[this$static._isRepG0[state] >>> 2] + ProbPrices[this$static._isRep0Long[(state << 4) + posState] >>> 2]);\n            if (shortRepPrice <= nextOptimum.Price) {\n                nextOptimum.Price = shortRepPrice;\n                nextOptimum.PosPrev = cur;\n                nextOptimum.BackPrev = 0;\n                nextOptimum.Prev1IsChar = 0;\n                nextIsChar = 1;\n            }\n        }\n        numAvailableBytesFull = $GetNumAvailableBytes(this$static._matchFinder) + 1;\n        numAvailableBytesFull = 4095 - cur < numAvailableBytesFull?4095 - cur:numAvailableBytesFull;\n        numAvailableBytes = numAvailableBytesFull;\n        if (numAvailableBytes < 2) {\n            continue;\n        }\n        if (numAvailableBytes > this$static._numFastBytes) {\n            numAvailableBytes = this$static._numFastBytes;\n        }\n        if (!nextIsChar && matchByte != currentByte) {\n            t = Math.min(numAvailableBytesFull - 1, this$static._numFastBytes);\n            lenTest2 = $GetMatchLen(this$static._matchFinder, 0, this$static.reps[0], t);\n            if (lenTest2 >= 2) {\n                state2 = StateUpdateChar(state);\n                posStateNext = position + 1 & this$static._posStateMask;\n                nextRepMatchPrice = curAnd1Price + ProbPrices[2048 - this$static._isMatch[(state2 << 4) + posStateNext] >>> 2] + ProbPrices[2048 - this$static._isRep[state2] >>> 2];\n                offset = cur + 1 + lenTest2;\n                while (lenEnd < offset) {\n                    this$static._optimum[lenEnd += 1].Price = 268435455;\n                }\n                curAndLenPrice = nextRepMatchPrice + (price = $GetPrice(this$static._repMatchLenEncoder, lenTest2 - 2, posStateNext) , price + $GetPureRepPrice(this$static, 0, state2, posStateNext));\n                optimum = this$static._optimum[offset];\n                if (curAndLenPrice < optimum.Price) {\n                    optimum.Price = curAndLenPrice;\n                    optimum.PosPrev = cur + 1;\n                    optimum.BackPrev = 0;\n                    optimum.Prev1IsChar = 1;\n                    optimum.Prev2 = 0;\n                }\n            }\n        }\n        startLen = 2;\n        for (repIndex = 0; repIndex < 4; ++repIndex) {\n            lenTest = $GetMatchLen(this$static._matchFinder, -1, this$static.reps[repIndex], numAvailableBytes);\n            if (lenTest < 2) {\n                continue;\n            }\n            lenTestTemp = lenTest;\n            do {\n                while (lenEnd < cur + lenTest) {\n                    this$static._optimum[lenEnd += 1].Price = 268435455;\n                }\n                curAndLenPrice = repMatchPrice + (price_0 = $GetPrice(this$static._repMatchLenEncoder, lenTest - 2, posState) , price_0 + $GetPureRepPrice(this$static, repIndex, state, posState));\n                optimum = this$static._optimum[cur + lenTest];\n                if (curAndLenPrice < optimum.Price) {\n                    optimum.Price = curAndLenPrice;\n                    optimum.PosPrev = cur;\n                    optimum.BackPrev = repIndex;\n                    optimum.Prev1IsChar = 0;\n                }\n            } while ((lenTest -= 1) >= 2);\n            lenTest = lenTestTemp;\n            if (!repIndex) {\n                startLen = lenTest + 1;\n            }\n            if (lenTest < numAvailableBytesFull) {\n                t = Math.min(numAvailableBytesFull - 1 - lenTest, this$static._numFastBytes);\n                lenTest2 = $GetMatchLen(this$static._matchFinder, lenTest, this$static.reps[repIndex], t);\n                if (lenTest2 >= 2) {\n                    state2 = state < 7?8:11;\n                    posStateNext = position + lenTest & this$static._posStateMask;\n                    curAndLenCharPrice = repMatchPrice + (price_1 = $GetPrice(this$static._repMatchLenEncoder, lenTest - 2, posState) , price_1 + $GetPureRepPrice(this$static, repIndex, state, posState)) + ProbPrices[this$static._isMatch[(state2 << 4) + posStateNext] >>> 2] + $GetPrice_0($GetSubCoder(this$static._literalEncoder, position + lenTest, $GetIndexByte(this$static._matchFinder, lenTest - 1 - 1)), 1, $GetIndexByte(this$static._matchFinder, lenTest - 1 - (this$static.reps[repIndex] + 1)), $GetIndexByte(this$static._matchFinder, lenTest - 1));\n                    state2 = StateUpdateChar(state2);\n                    posStateNext = position + lenTest + 1 & this$static._posStateMask;\n                    nextMatchPrice = curAndLenCharPrice + ProbPrices[2048 - this$static._isMatch[(state2 << 4) + posStateNext] >>> 2];\n                    nextRepMatchPrice = nextMatchPrice + ProbPrices[2048 - this$static._isRep[state2] >>> 2];\n                    offset = lenTest + 1 + lenTest2;\n                    while (lenEnd < cur + offset) {\n                        this$static._optimum[lenEnd += 1].Price = 268435455;\n                    }\n                    curAndLenPrice = nextRepMatchPrice + (price_2 = $GetPrice(this$static._repMatchLenEncoder, lenTest2 - 2, posStateNext) , price_2 + $GetPureRepPrice(this$static, 0, state2, posStateNext));\n                    optimum = this$static._optimum[cur + offset];\n                    if (curAndLenPrice < optimum.Price) {\n                        optimum.Price = curAndLenPrice;\n                        optimum.PosPrev = cur + lenTest + 1;\n                        optimum.BackPrev = 0;\n                        optimum.Prev1IsChar = 1;\n                        optimum.Prev2 = 1;\n                        optimum.PosPrev2 = cur;\n                        optimum.BackPrev2 = repIndex;\n                    }\n                }\n            }\n        }\n        if (newLen > numAvailableBytes) {\n            newLen = numAvailableBytes;\n            for (numDistancePairs = 0; newLen > this$static._matchDistances[numDistancePairs]; numDistancePairs += 2) {}\n            this$static._matchDistances[numDistancePairs] = newLen;\n            numDistancePairs += 2;\n        }\n        if (newLen >= startLen) {\n        normalMatchPrice = matchPrice + ProbPrices[this$static._isRep[state] >>> 2];\n        while (lenEnd < cur + newLen) {\n            this$static._optimum[lenEnd += 1].Price = 268435455;\n        }\n        offs = 0;\n        while (startLen > this$static._matchDistances[offs]) {\n            offs += 2;\n        }\n        for (lenTest = startLen;; lenTest += 1) {\n            curBack = this$static._matchDistances[offs + 1];\n            curAndLenPrice = normalMatchPrice + $GetPosLenPrice(this$static, curBack, lenTest, posState);\n            optimum = this$static._optimum[cur + lenTest];\n            if (curAndLenPrice < optimum.Price) {\n                optimum.Price = curAndLenPrice;\n                optimum.PosPrev = cur;\n                optimum.BackPrev = curBack + 4;\n                optimum.Prev1IsChar = 0;\n            }\n            if (lenTest == this$static._matchDistances[offs]) {\n                if (lenTest < numAvailableBytesFull) {\n                    t = Math.min(numAvailableBytesFull - 1 - lenTest, this$static._numFastBytes);\n                    lenTest2 = $GetMatchLen(this$static._matchFinder, lenTest, curBack, t);\n                    if (lenTest2 >= 2) {\n                        state2 = state < 7?7:10;\n                        posStateNext = position + lenTest & this$static._posStateMask;\n                        curAndLenCharPrice = curAndLenPrice + ProbPrices[this$static._isMatch[(state2 << 4) + posStateNext] >>> 2] + $GetPrice_0($GetSubCoder(this$static._literalEncoder, position + lenTest, $GetIndexByte(this$static._matchFinder, lenTest - 1 - 1)), 1, $GetIndexByte(this$static._matchFinder, lenTest - (curBack + 1) - 1), $GetIndexByte(this$static._matchFinder, lenTest - 1));\n                        state2 = StateUpdateChar(state2);\n                        posStateNext = position + lenTest + 1 & this$static._posStateMask;\n                        nextMatchPrice = curAndLenCharPrice + ProbPrices[2048 - this$static._isMatch[(state2 << 4) + posStateNext] >>> 2];\n                        nextRepMatchPrice = nextMatchPrice + ProbPrices[2048 - this$static._isRep[state2] >>> 2];\n                        offset = lenTest + 1 + lenTest2;\n                        while (lenEnd < cur + offset) {\n                            this$static._optimum[lenEnd += 1].Price = 268435455;\n                        }\n                        curAndLenPrice = nextRepMatchPrice + (price_3 = $GetPrice(this$static._repMatchLenEncoder, lenTest2 - 2, posStateNext) , price_3 + $GetPureRepPrice(this$static, 0, state2, posStateNext));\n                        optimum = this$static._optimum[cur + offset];\n                        if (curAndLenPrice < optimum.Price) {\n                            optimum.Price = curAndLenPrice;\n                            optimum.PosPrev = cur + lenTest + 1;\n                            optimum.BackPrev = 0;\n                            optimum.Prev1IsChar = 1;\n                            optimum.Prev2 = 1;\n                            optimum.PosPrev2 = cur;\n                            optimum.BackPrev2 = curBack + 4;\n                        }\n                    }\n                }\n                offs += 2;\n                if (offs == numDistancePairs)\n                    break;\n                }\n            }\n        }\n    }\n}\n\nfunction $GetPosLenPrice(this$static, pos, len, posState) {\n    var price, lenToPosState = GetLenToPosState(len);\n    if (pos < 128) {\n        price = this$static._distancesPrices[lenToPosState * 128 + pos];\n    } else {\n        price = this$static._posSlotPrices[(lenToPosState << 6) + GetPosSlot2(pos)] + this$static._alignPrices[pos & 15];\n    }\n    return price + $GetPrice(this$static._lenEncoder, len - 2, posState);\n}\n\nfunction $GetPureRepPrice(this$static, repIndex, state, posState) {\n    var price;\n    if (!repIndex) {\n        price = ProbPrices[this$static._isRepG0[state] >>> 2];\n        price += ProbPrices[2048 - this$static._isRep0Long[(state << 4) + posState] >>> 2];\n    } else {\n        price = ProbPrices[2048 - this$static._isRepG0[state] >>> 2];\n        if (repIndex == 1) {\n            price += ProbPrices[this$static._isRepG1[state] >>> 2];\n        } else {\n            price += ProbPrices[2048 - this$static._isRepG1[state] >>> 2];\n            price += GetPrice(this$static._isRepG2[state], repIndex - 2);\n        }\n    }\n    return price;\n}\n\nfunction $GetRepLen1Price(this$static, state, posState) {\n    return ProbPrices[this$static._isRepG0[state] >>> 2] + ProbPrices[this$static._isRep0Long[(state << 4) + posState] >>> 2];\n}\n\nfunction $Init_4(this$static) {\n    $BaseInit(this$static);\n    $Init_9(this$static._rangeEncoder);\n    InitBitModels(this$static._isMatch);\n    InitBitModels(this$static._isRep0Long);\n    InitBitModels(this$static._isRep);\n    InitBitModels(this$static._isRepG0);\n    InitBitModels(this$static._isRepG1);\n    InitBitModels(this$static._isRepG2);\n    InitBitModels(this$static._posEncoders);\n    $Init_3(this$static._literalEncoder);\n    for (var i = 0; i < 4; ++i) {\n        InitBitModels(this$static._posSlotEncoder[i].Models);\n    }\n    $Init_2(this$static._lenEncoder, 1 << this$static._posStateBits);\n    $Init_2(this$static._repMatchLenEncoder, 1 << this$static._posStateBits);\n    InitBitModels(this$static._posAlignEncoder.Models);\n    this$static._longestMatchWasFound = 0;\n    this$static._optimumEndIndex = 0;\n    this$static._optimumCurrentIndex = 0;\n    this$static._additionalOffset = 0;\n}\n\nfunction $MovePos(this$static, num) {\n    if (num > 0) {\n        $Skip(this$static._matchFinder, num);\n        this$static._additionalOffset += num;\n    }\n}\n\nfunction $ReadMatchDistances(this$static) {\n    var lenRes = 0;\n    this$static._numDistancePairs = $GetMatches(this$static._matchFinder, this$static._matchDistances);\n    if (this$static._numDistancePairs > 0) {\n        lenRes = this$static._matchDistances[this$static._numDistancePairs - 2];\n        if (lenRes == this$static._numFastBytes)\n        lenRes += $GetMatchLen(this$static._matchFinder, lenRes - 1, this$static._matchDistances[this$static._numDistancePairs - 1], 273 - lenRes);\n    }\n    this$static._additionalOffset += 1;\n    return lenRes;\n}\n\nfunction $ReleaseMFStream(this$static) {\n    if (this$static._matchFinder && this$static._needReleaseMFStream) {\n        this$static._matchFinder._stream = null;\n        this$static._needReleaseMFStream = 0;\n    }\n}\n\nfunction $ReleaseStreams(this$static) {\n    $ReleaseMFStream(this$static);\n    this$static._rangeEncoder.Stream = null;\n}\n\nfunction $SetDictionarySize_0(this$static, dictionarySize) {\n    this$static._dictionarySize = dictionarySize;\n    for (var dicLogSize = 0; dictionarySize > 1 << dicLogSize; ++dicLogSize) {}\n    this$static._distTableSize = dicLogSize * 2;\n}\n\nfunction $SetMatchFinder(this$static, matchFinderIndex) {\n    var matchFinderIndexPrev = this$static._matchFinderType;\n    this$static._matchFinderType = matchFinderIndex;\n    if (this$static._matchFinder && matchFinderIndexPrev != this$static._matchFinderType) {\n        this$static._dictionarySizePrev = -1;\n        this$static._matchFinder = null;\n    }\n}\n\nfunction $WriteCoderProperties(this$static, outStream) {\n    this$static.properties[0] = (this$static._posStateBits * 5 + this$static._numLiteralPosStateBits) * 9 + this$static._numLiteralContextBits << 24 >> 24;\n    for (var i = 0; i < 4; ++i) {\n        this$static.properties[1 + i] = this$static._dictionarySize >> 8 * i << 24 >> 24;\n    }\n    $write_0(outStream, this$static.properties, 0, 5);\n}\n\nfunction $WriteEndMarker(this$static, posState) {\n    //if (!this$static._writeEndMark) {\n    //    return;\n    //}\n    $Encode_3(this$static._rangeEncoder, this$static._isMatch, (this$static._state << 4) + posState, 1);\n    $Encode_3(this$static._rangeEncoder, this$static._isRep, this$static._state, 0);\n    this$static._state = this$static._state < 7?7:10;\n    $Encode_0(this$static._lenEncoder, this$static._rangeEncoder, 0, posState);\n    var lenToPosState = GetLenToPosState(2);\n    $Encode_2(this$static._posSlotEncoder[lenToPosState], this$static._rangeEncoder, 63);\n    $EncodeDirectBits(this$static._rangeEncoder, 67108863, 26);\n    $ReverseEncode(this$static._posAlignEncoder, this$static._rangeEncoder, 15);\n}\n\nfunction GetPosSlot(pos) {\n    if (pos < 2048) {\n        return g_FastPos[pos];\n    }\n    if (pos < 2097152) {\n        return g_FastPos[pos >> 10] + 20;\n    }\n    return g_FastPos[pos >> 20] + 40;\n}\n\nfunction GetPosSlot2(pos) {\n    if (pos < 131072) {\n        return g_FastPos[pos >> 6] + 12;\n    }\n    if (pos < 134217728) {\n        return g_FastPos[pos >> 16] + 32;\n    }\n    return g_FastPos[pos >> 26] + 52;\n}\n\nfunction $Encode(this$static, rangeEncoder, symbol, posState) {\n    if (symbol < 8) {\n        $Encode_3(rangeEncoder, this$static._choice, 0, 0);\n        $Encode_2(this$static._lowCoder[posState], rangeEncoder, symbol);\n    } else {\n        symbol -= 8;\n        $Encode_3(rangeEncoder, this$static._choice, 0, 1);\n        if (symbol < 8) {\n            $Encode_3(rangeEncoder, this$static._choice, 1, 0);\n            $Encode_2(this$static._midCoder[posState], rangeEncoder, symbol);\n        } else {\n            $Encode_3(rangeEncoder, this$static._choice, 1, 1);\n            $Encode_2(this$static._highCoder, rangeEncoder, symbol - 8);\n        }\n    }\n}\n\nfunction $Encoder$LenEncoder(this$static) {\n    this$static._choice = initDim(2);\n    this$static._lowCoder = initDim(16);\n    this$static._midCoder = initDim(16);\n    this$static._highCoder = $BitTreeEncoder({}, 8);\n    for (var posState = 0; posState < 16; ++posState) {\n        this$static._lowCoder[posState] = $BitTreeEncoder({}, 3);\n        this$static._midCoder[posState] = $BitTreeEncoder({}, 3);\n    }\n    return this$static;\n}\n\nfunction $Init_2(this$static, numPosStates) {\n    InitBitModels(this$static._choice);\n    for (var posState = 0; posState < numPosStates; ++posState) {\n        InitBitModels(this$static._lowCoder[posState].Models);\n        InitBitModels(this$static._midCoder[posState].Models);\n    }\n    InitBitModels(this$static._highCoder.Models);\n}\n\nfunction $SetPrices(this$static, posState, numSymbols, prices, st) {\n    var a0, a1, b0, b1, i;\n    a0 = ProbPrices[this$static._choice[0] >>> 2];\n    a1 = ProbPrices[2048 - this$static._choice[0] >>> 2];\n    b0 = a1 + ProbPrices[this$static._choice[1] >>> 2];\n    b1 = a1 + ProbPrices[2048 - this$static._choice[1] >>> 2];\n    i = 0;\n    for (i = 0; i < 8; ++i) {\n        if (i >= numSymbols)\n        return;\n        prices[st + i] = a0 + $GetPrice_1(this$static._lowCoder[posState], i);\n    }\n    for (; i < 16; ++i) {\n        if (i >= numSymbols)\n        return;\n        prices[st + i] = b0 + $GetPrice_1(this$static._midCoder[posState], i - 8);\n    }\n    for (; i < numSymbols; ++i) {\n        prices[st + i] = b1 + $GetPrice_1(this$static._highCoder, i - 8 - 8);\n    }\n}\n\nfunction $Encode_0(this$static, rangeEncoder, symbol, posState) {\n    $Encode(this$static, rangeEncoder, symbol, posState);\n    if ((this$static._counters[posState] -= 1) == 0) {\n        $SetPrices(this$static, posState, this$static._tableSize, this$static._prices, posState * 272);\n        this$static._counters[posState] = this$static._tableSize;\n    }\n}\n\nfunction $Encoder$LenPriceTableEncoder(this$static) {\n    $Encoder$LenEncoder(this$static);\n    this$static._prices = [];\n    this$static._counters = [];\n    return this$static;\n}\n\nfunction $GetPrice(this$static, symbol, posState) {\n    return this$static._prices[posState * 272 + symbol];\n}\n\nfunction $UpdateTables(this$static, numPosStates) {\n    for (var posState = 0; posState < numPosStates; ++posState) {\n        $SetPrices(this$static, posState, this$static._tableSize, this$static._prices, posState * 272);\n        this$static._counters[posState] = this$static._tableSize;\n    }\n}\n\nfunction $Create_1(this$static, numPosBits, numPrevBits) {\n    var i, numStates;\n    if (this$static.m_Coders != null && this$static.m_NumPrevBits == numPrevBits && this$static.m_NumPosBits == numPosBits) {\n        return;\n    }\n    this$static.m_NumPosBits = numPosBits;\n    this$static.m_PosMask = (1 << numPosBits) - 1;\n    this$static.m_NumPrevBits = numPrevBits;\n    numStates = 1 << this$static.m_NumPrevBits + this$static.m_NumPosBits;\n    this$static.m_Coders = initDim(numStates);\n    for (i = 0; i < numStates; ++i) {\n        this$static.m_Coders[i] = $Encoder$LiteralEncoder$Encoder2({});\n    }\n}\n\nfunction $GetSubCoder(this$static, pos, prevByte) {\n    return this$static.m_Coders[((pos & this$static.m_PosMask) << this$static.m_NumPrevBits) + ((prevByte & 255) >>> 8 - this$static.m_NumPrevBits)];\n}\n\nfunction $Init_3(this$static) {\n    var i, numStates = 1 << this$static.m_NumPrevBits + this$static.m_NumPosBits;\n    for (i = 0; i < numStates; ++i) {\n        InitBitModels(this$static.m_Coders[i].m_Encoders);\n    }\n}\n\nfunction $Encode_1(this$static, rangeEncoder, symbol) {\n    var bit, i, context = 1;\n    for (i = 7; i >= 0; --i) {\n        bit = symbol >> i & 1;\n        $Encode_3(rangeEncoder, this$static.m_Encoders, context, bit);\n        context = context << 1 | bit;\n    }\n}\n\nfunction $EncodeMatched(this$static, rangeEncoder, matchByte, symbol) {\n    var bit, i, matchBit, state, same = 1, context = 1;\n    for (i = 7; i >= 0; --i) {\n        bit = symbol >> i & 1;\n        state = context;\n        if (same) {\n            matchBit = matchByte >> i & 1;\n            state += 1 + matchBit << 8;\n            same = matchBit == bit;\n        }\n        $Encode_3(rangeEncoder, this$static.m_Encoders, state, bit);\n        context = context << 1 | bit;\n    }\n}\n\nfunction $Encoder$LiteralEncoder$Encoder2(this$static) {\n    this$static.m_Encoders = initDim(768);\n    return this$static;\n}\n\nfunction $GetPrice_0(this$static, matchMode, matchByte, symbol) {\n    var bit, context = 1, i = 7, matchBit, price = 0;\n    if (matchMode) {\n        for (; i >= 0; --i) {\n            matchBit = matchByte >> i & 1;\n            bit = symbol >> i & 1;\n            price += GetPrice(this$static.m_Encoders[(1 + matchBit << 8) + context], bit);\n            context = context << 1 | bit;\n            if (matchBit != bit) {\n                --i;\n                break;\n            }\n        }\n    }\n    for (; i >= 0; --i) {\n        bit = symbol >> i & 1;\n        price += GetPrice(this$static.m_Encoders[context], bit);\n        context = context << 1 | bit;\n    }\n    return price;\n}\n\nfunction $MakeAsChar(this$static) {\n    this$static.BackPrev = -1;\n    this$static.Prev1IsChar = 0;\n}\n\nfunction $MakeAsShortRep(this$static) {\n    this$static.BackPrev = 0;\n    this$static.Prev1IsChar = 0;\n}\n/** ce */\n/** ds */\nfunction $BitTreeDecoder(this$static, numBitLevels) {\n    this$static.NumBitLevels = numBitLevels;\n    this$static.Models = initDim(1 << numBitLevels);\n    return this$static;\n}\n\nfunction $Decode_0(this$static, rangeDecoder) {\n    var bitIndex, m = 1;\n    for (bitIndex = this$static.NumBitLevels; bitIndex != 0; bitIndex -= 1) {\n        m = (m << 1) + $DecodeBit(rangeDecoder, this$static.Models, m);\n    }\n    return m - (1 << this$static.NumBitLevels);\n}\n\nfunction $ReverseDecode(this$static, rangeDecoder) {\n    var bit, bitIndex, m = 1, symbol = 0;\n    for (bitIndex = 0; bitIndex < this$static.NumBitLevels; ++bitIndex) {\n        bit = $DecodeBit(rangeDecoder, this$static.Models, m);\n        m <<= 1;\n        m += bit;\n        symbol |= bit << bitIndex;\n    }\n    return symbol;\n}\n\nfunction ReverseDecode(Models, startIndex, rangeDecoder, NumBitLevels) {\n    var bit, bitIndex, m = 1, symbol = 0;\n    for (bitIndex = 0; bitIndex < NumBitLevels; ++bitIndex) {\n        bit = $DecodeBit(rangeDecoder, Models, startIndex + m);\n        m <<= 1;\n        m += bit;\n        symbol |= bit << bitIndex;\n    }\n    return symbol;\n}\n/** de */\n/** cs */\nfunction $BitTreeEncoder(this$static, numBitLevels) {\n    this$static.NumBitLevels = numBitLevels;\n    this$static.Models = initDim(1 << numBitLevels);\n    return this$static;\n}\n\nfunction $Encode_2(this$static, rangeEncoder, symbol) {\n    var bit, bitIndex, m = 1;\n    for (bitIndex = this$static.NumBitLevels; bitIndex != 0;) {\n        bitIndex -= 1;\n        bit = symbol >>> bitIndex & 1;\n        $Encode_3(rangeEncoder, this$static.Models, m, bit);\n        m = m << 1 | bit;\n    }\n}\n\nfunction $GetPrice_1(this$static, symbol) {\n    var bit, bitIndex, m = 1, price = 0;\n    for (bitIndex = this$static.NumBitLevels; bitIndex != 0;) {\n        bitIndex -= 1;\n        bit = symbol >>> bitIndex & 1;\n        price += GetPrice(this$static.Models[m], bit);\n        m = (m << 1) + bit;\n    }\n    return price;\n}\n\nfunction $ReverseEncode(this$static, rangeEncoder, symbol) {\n    var bit, i, m = 1;\n    for (i = 0; i < this$static.NumBitLevels; ++i) {\n        bit = symbol & 1;\n        $Encode_3(rangeEncoder, this$static.Models, m, bit);\n        m = m << 1 | bit;\n        symbol >>= 1;\n    }\n}\n\nfunction $ReverseGetPrice(this$static, symbol) {\n    var bit, i, m = 1, price = 0;\n    for (i = this$static.NumBitLevels; i != 0; i -= 1) {\n        bit = symbol & 1;\n        symbol >>>= 1;\n        price += GetPrice(this$static.Models[m], bit);\n        m = m << 1 | bit;\n    }\n    return price;\n}\n\nfunction ReverseEncode(Models, startIndex, rangeEncoder, NumBitLevels, symbol) {\n    var bit, i, m = 1;\n    for (i = 0; i < NumBitLevels; ++i) {\n        bit = symbol & 1;\n        $Encode_3(rangeEncoder, Models, startIndex + m, bit);\n        m = m << 1 | bit;\n        symbol >>= 1;\n    }\n}\n\nfunction ReverseGetPrice(Models, startIndex, NumBitLevels, symbol) {\n    var bit, i, m = 1, price = 0;\n    for (i = NumBitLevels; i != 0; i -= 1) {\n        bit = symbol & 1;\n        symbol >>>= 1;\n        price += ProbPrices[((Models[startIndex + m] - bit ^ -bit) & 2047) >>> 2];\n        m = m << 1 | bit;\n    }\n    return price;\n}\n/** ce */\n/** ds */\nfunction $DecodeBit(this$static, probs, index) {\n    var newBound, prob = probs[index];\n    newBound = (this$static.Range >>> 11) * prob;\n    if ((this$static.Code ^ -2147483648) < (newBound ^ -2147483648)) {\n        this$static.Range = newBound;\n        probs[index] = prob + (2048 - prob >>> 5) << 16 >> 16;\n        if (!(this$static.Range & -16777216)) {\n            this$static.Code = this$static.Code << 8 | $read(this$static.Stream);\n            this$static.Range <<= 8;\n        }\n        return 0;\n    } else {\n        this$static.Range -= newBound;\n        this$static.Code -= newBound;\n        probs[index] = prob - (prob >>> 5) << 16 >> 16;\n        if (!(this$static.Range & -16777216)) {\n            this$static.Code = this$static.Code << 8 | $read(this$static.Stream);\n            this$static.Range <<= 8;\n        }\n        return 1;\n    }\n}\n\nfunction $DecodeDirectBits(this$static, numTotalBits) {\n    var i, t, result = 0;\n    for (i = numTotalBits; i != 0; i -= 1) {\n        this$static.Range >>>= 1;\n        t = this$static.Code - this$static.Range >>> 31;\n        this$static.Code -= this$static.Range & t - 1;\n        result = result << 1 | 1 - t;\n        if (!(this$static.Range & -16777216)) {\n            this$static.Code = this$static.Code << 8 | $read(this$static.Stream);\n            this$static.Range <<= 8;\n        }\n    }\n    return result;\n}\n\nfunction $Init_8(this$static) {\n    this$static.Code = 0;\n    this$static.Range = -1;\n    for (var i = 0; i < 5; ++i) {\n        this$static.Code = this$static.Code << 8 | $read(this$static.Stream);\n    }\n}\n/** de */\n\nfunction InitBitModels(probs) {\n    for (var i = probs.length - 1; i >= 0; --i) {\n        probs[i] = 1024;\n    }\n}\n/** cs */\nvar ProbPrices = (function () {\n    var end, i, j, start, ProbPrices = [];\n    for (i = 8; i >= 0; --i) {\n        start = 1;\n        start <<= 9 - i - 1;\n        end = 1;\n        end <<= 9 - i;\n        for (j = start; j < end; ++j) {\n            ProbPrices[j] = (i << 6) + (end - j << 6 >>> 9 - i - 1);\n        }\n    }\n    return ProbPrices;\n}());\n\nfunction $Encode_3(this$static, probs, index, symbol) {\n    var newBound, prob = probs[index];\n    newBound = (this$static.Range >>> 11) * prob;\n    if (!symbol) {\n        this$static.Range = newBound;\n        probs[index] = prob + (2048 - prob >>> 5) << 16 >> 16;\n    } else {\n        this$static.Low = add(this$static.Low, and(fromInt(newBound), [4294967295, 0]));\n        this$static.Range -= newBound;\n        probs[index] = prob - (prob >>> 5) << 16 >> 16;\n    }\n    if (!(this$static.Range & -16777216)) {\n        this$static.Range <<= 8;\n        $ShiftLow(this$static);\n    }\n}\n\nfunction $EncodeDirectBits(this$static, v, numTotalBits) {\n    for (var i = numTotalBits - 1; i >= 0; i -= 1) {\n        this$static.Range >>>= 1;\n        if ((v >>> i & 1) == 1) {\n            this$static.Low = add(this$static.Low, fromInt(this$static.Range));\n        }\n        if (!(this$static.Range & -16777216)) {\n            this$static.Range <<= 8;\n            $ShiftLow(this$static);\n        }\n    }\n}\n\nfunction $GetProcessedSizeAdd(this$static) {\n    return add(add(fromInt(this$static._cacheSize), this$static._position), [4, 0]);\n}\n\nfunction $Init_9(this$static) {\n    this$static._position = P0_longLit;\n    this$static.Low = P0_longLit;\n    this$static.Range = -1;\n    this$static._cacheSize = 1;\n    this$static._cache = 0;\n}\n\nfunction $ShiftLow(this$static) {\n    var temp, LowHi = lowBits_0(shru(this$static.Low, 32));\n    if (LowHi != 0 || compare(this$static.Low, [4278190080, 0]) < 0) {\n        this$static._position = add(this$static._position, fromInt(this$static._cacheSize));\n        temp = this$static._cache;\n        do {\n            $write(this$static.Stream, temp + LowHi);\n            temp = 255;\n        } while ((this$static._cacheSize -= 1) != 0);\n        this$static._cache = lowBits_0(this$static.Low) >>> 24;\n    }\n    this$static._cacheSize += 1;\n    this$static.Low = shl(and(this$static.Low, [16777215, 0]), 8);\n}\n\nfunction GetPrice(Prob, symbol) {\n    return ProbPrices[((Prob - symbol ^ -symbol) & 2047) >>> 2];\n}\n\n/** ce */\n/** ds */\nfunction decode(utf) {\n    var i = 0, j = 0, x, y, z, l = utf.length, buf = [], charCodes = [];\n    for (; i < l; ++i, ++j) {\n        x = utf[i] & 255;\n        if (!(x & 128)) {\n            if (!x) {\n                /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.\n                return utf;\n            }\n            charCodes[j] = x;\n        } else if ((x & 224) == 192) {\n            if (i + 1 >= l) {\n                /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.\n                return utf;\n            }\n            y = utf[++i] & 255;\n            if ((y & 192) != 128) {\n                /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.\n                return utf;\n            }\n            charCodes[j] = ((x & 31) << 6) | (y & 63);\n        } else if ((x & 240) == 224) {\n            if (i + 2 >= l) {\n                /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.\n                return utf;\n            }\n            y = utf[++i] & 255;\n            if ((y & 192) != 128) {\n                /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.\n                return utf;\n            }\n            z = utf[++i] & 255;\n            if ((z & 192) != 128) {\n                /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.\n                return utf;\n            }\n            charCodes[j] = ((x & 15) << 12) | ((y & 63) << 6) | (z & 63);\n        } else {\n            /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.\n            return utf;\n        }\n        if (j == 16383) {\n            buf.push(String.fromCharCode.apply(String, charCodes));\n            j = -1;\n        }\n    }\n    if (j > 0) {\n        charCodes.length = j;\n        buf.push(String.fromCharCode.apply(String, charCodes));\n    }\n    return buf.join(\"\");\n}\n/** de */\n/** cs */\nfunction encode(s) {\n    var ch, chars = [], data, elen = 0, i, l = s.length;\n    /// Be able to handle binary arrays and buffers.\n    if (typeof s == \"object\") {\n        return s;\n    } else {\n        $getChars(s, 0, l, chars, 0);\n    }\n    /// Add extra spaces in the array to break up the unicode symbols.\n    for (i = 0; i < l; ++i) {\n        ch = chars[i];\n        if (ch >= 1 && ch <= 127) {\n            ++elen;\n        } else if (!ch || ch >= 128 && ch <= 2047) {\n            elen += 2;\n        } else {\n            elen += 3;\n        }\n    }\n    data = [];\n    elen = 0;\n    for (i = 0; i < l; ++i) {\n        ch = chars[i];\n        if (ch >= 1 && ch <= 127) {\n            data[elen++] = ch << 24 >> 24;\n        } else if (!ch || ch >= 128 && ch <= 2047) {\n            data[elen++] = (192 | ch >> 6 & 31) << 24 >> 24;\n            data[elen++] = (128 | ch & 63) << 24 >> 24;\n        } else {\n            data[elen++] = (224 | ch >> 12 & 15) << 24 >> 24;\n            data[elen++] = (128 | ch >> 6 & 63) << 24 >> 24;\n            data[elen++] = (128 | ch & 63) << 24 >> 24;\n        }\n    }\n    return data;\n}\n/** ce */\n\nfunction toDouble(a) {\n    return a[1] + a[0];\n}\n\n/** cs */\nexport function compress(str, mode, on_finish, on_progress) {\n    var this$static = {},\n        percent,\n        cbn, /// A callback number should be supplied instead of on_finish() if we are using Web Workers.\n        sync = typeof on_finish == \"undefined\" && typeof on_progress == \"undefined\";\n    \n    if (typeof on_finish != \"function\") {\n        cbn = on_finish;\n        on_finish = on_progress = 0;\n    }\n    \n    on_progress = on_progress || function(percent) {\n        if (typeof cbn == \"undefined\")\n            return;\n        \n        return update_progress(percent, cbn);\n    };\n    \n    on_finish = on_finish || function(res, err) {\n        if (typeof cbn == \"undefined\")\n            return;\n        \n        return postMessage({\n            \"action\": action_compress,\n            \"cbn\": cbn,\n            \"result\": res,\n            \"error\": err\n        });\n    };\n\n    if (sync) {\n        this$static.c = $LZMAByteArrayCompressor({}, encode(str), get_mode_obj(mode));\n        while ($processChunkEncode(this$static.c.chunker));\n        return $toByteArray(this$static.c.output);\n    }\n    \n    try {\n        this$static.c = $LZMAByteArrayCompressor({}, encode(str), get_mode_obj(mode));\n        \n        on_progress(0);\n    } catch (err) {\n        return on_finish(null, err);\n    }\n    \n    function do_action() {\n        try {\n            var res, start = (new Date()).getTime();\n            \n            while ($processChunkEncode(this$static.c.chunker)) {\n                percent = toDouble(this$static.c.chunker.inBytesProcessed) / toDouble(this$static.c.length_0);\n                /// If about 200 miliseconds have passed, update the progress.\n                if ((new Date()).getTime() - start > 200) {\n                    on_progress(percent);\n                    \n                    wait(do_action, 0);\n                    return 0;\n                }\n            }\n            \n            on_progress(1);\n            \n            res = $toByteArray(this$static.c.output);\n            \n            /// delay so we donât catch errors from the on_finish handler\n            wait(on_finish.bind(null, res), 0);\n        } catch (err) {\n            on_finish(null, err);\n        }\n    }\n    \n    ///NOTE: We need to wait to make sure it is always async.\n    wait(do_action, 0);\n}\n/** ce */\n/** ds */\nexport function decompress(byte_arr, on_finish, on_progress) {\n    var this$static = {},\n        percent,\n        cbn, /// A callback number should be supplied instead of on_finish() if we are using Web Workers.\n        has_progress,\n        len,\n        sync = typeof on_finish == \"undefined\" && typeof on_progress == \"undefined\";\n\n    if (typeof on_finish != \"function\") {\n        cbn = on_finish;\n        on_finish = on_progress = 0;\n    }\n    \n    on_progress = on_progress || function(percent) {\n        if (typeof cbn == \"undefined\")\n            return;\n        \n        return update_progress(has_progress ? percent : -1, cbn);\n    };\n    \n    on_finish = on_finish || function(res, err) {\n        if (typeof cbn == \"undefined\")\n            return;\n        \n        return postMessage({\n            \"action\": action_decompress,\n            \"cbn\": cbn,\n            \"result\": res,\n            \"error\": err\n        });\n    };\n\n    if (sync) {\n        this$static.d = $LZMAByteArrayDecompressor({}, byte_arr);\n        while ($processChunkDecode(this$static.d.chunker));\n        return decode($toByteArray(this$static.d.output));\n    }\n    \n    try {\n        this$static.d = $LZMAByteArrayDecompressor({}, byte_arr);\n        \n        len = toDouble(this$static.d.length_0);\n        \n        ///NOTE: If the data was created via a stream, it will not have a length value, and therefore we can't calculate the progress.\n        has_progress = len > -1;\n        \n        on_progress(0);\n    } catch (err) {\n        return on_finish(null, err);\n    }\n    \n    function do_action() {\n        try {\n            var res, i = 0, start = (new Date()).getTime();\n            while ($processChunkDecode(this$static.d.chunker)) {\n                if (++i % 1000 == 0 && (new Date()).getTime() - start > 200) {\n                    if (has_progress) {\n                        percent = toDouble(this$static.d.chunker.decoder.nowPos64) / len;\n                        /// If about 200 miliseconds have passed, update the progress.\n                        on_progress(percent);\n                    }\n                    \n                    ///NOTE: This allows other code to run, like the browser to update.\n                    wait(do_action, 0);\n                    return 0;\n                }\n            }\n            \n            on_progress(1);\n            \n            res = decode($toByteArray(this$static.d.output));\n            \n            /// delay so we donât catch errors from the on_finish handler\n            wait(on_finish.bind(null, res), 0);\n        } catch (err) {\n            on_finish(null, err);\n        }\n    }\n    \n    ///NOTE: We need to wait to make sure it is always async.\n    wait(do_action, 0);\n}\n/** de */\n/** cs */\nvar get_mode_obj = (function () {\n    /// s is dictionarySize\n    /// f is fb\n    /// m is matchFinder\n    ///NOTE: Because some values are always the same, they have been removed.\n    /// lc is always 3\n    /// lp is always 0\n    /// pb is always 2\n    var modes = [\n        {s: 16, f:  64, m: 0},\n        {s: 20, f:  64, m: 0},\n        {s: 19, f:  64, m: 1},\n        {s: 20, f:  64, m: 1},\n        {s: 21, f: 128, m: 1},\n        {s: 22, f: 128, m: 1},\n        {s: 23, f: 128, m: 1},\n        {s: 24, f: 255, m: 1},\n        {s: 25, f: 255, m: 1}\n    ];\n    \n    return function (mode) {\n        return modes[mode - 1] || modes[6];\n    };\n}());\n/** ce */\n","import { compress, decompress, action_compress, action_decompress } from \"./lzma-algo\";\n\nexport { compress, decompress };\n\nexport var LZMA = function () {};\nLZMA[\"compress\"] = compress;\nLZMA[\"decompress\"] = decompress;\nLZMA.prototype[\"compress\"] = compress;\nLZMA.prototype[\"decompress\"] = decompress;\n\nexport var LZMA_WORKER = LZMA;\n\nif (typeof self != \"undefined\" && 'importScripts' in self) {\n    addEventListener(\"message\", function (e) {\n        if (e[\"data\"][\"action\"] == action_compress) {\n            compress(e.data[\"data\"], e[\"data\"][\"mode\"], e[\"data\"][\"cbn\"]);\n        } else if (e[\"data\"][\"action\"] == action_decompress) {\n            decompress(e[\"data\"][\"data\"], e[\"data\"][\"cbn\"]);\n        }\n    });\n}"],"names":["wait","setImmediate","setTimeout","N1_longLit","MIN_VALUE","P0_longLit","P1_longLit","update_progress","percent","cbn","postMessage","action","result","initDim","len","a","undefined","add","b","create","and","highBits","lowBits","low","makeFromBits","Math","max","min","lowBits_0","compare","nega","negb","sub","valueLow","valueHigh","diffHigh","diffLow","floor","eq","fromInt","value","pwrAsDouble","n","shl","diff","newHigh","newLow","twoToN","Error","shr","shiftFact","$ByteArrayInputStream","this$static","buf","pos","count","length","$read","$read_0","off","arraycopy","$ByteArrayOutputStream","$toByteArray","data","$write","$write_0","src","srcOfs","dest","destOfs","i","$init","input","output","length_0","mode","encoder","dictionarySize","_dictionarySize","dicLogSize","_distTableSize","$SetDictionarySize_0","s","_numFastBytes","f","matchFinderIndex","matchFinderIndexPrev","_matchFinderType","_matchFinder","_dictionarySizePrev","$SetMatchFinder","m","_numLiteralPosStateBits","_numLiteralContextBits","_posStateBits","_posStateMask","$configure","_repDistances","_optimum","_rangeEncoder","_isMatch","_isRep","_isRepG0","_isRepG1","_isRepG2","_isRep0Long","_posSlotEncoder","_posEncoders","_posAlignEncoder","$BitTreeEncoder","_lenEncoder","$Encoder$LenPriceTableEncoder","_repMatchLenEncoder","_literalEncoder","_matchDistances","_posSlotPrices","_distancesPrices","_alignPrices","reps","repLens","processedInSize","processedOutSize","finished","properties","tempPrices","_longestMatchLength","_numDistancePairs","_numFastBytesPrev","backRes","$Encoder","outStream","$WriteCoderProperties","chunker","_needReleaseMFStream","_inStream","_finished","bt","numHashBytes","HASH_ARRAY","kNumHashDirectBytes","kMinMatchCheck","kFixHashSize","$SetType","numPosBits","numPrevBits","numStates","m_Coders","m_NumPrevBits","m_NumPosBits","m_PosMask","$Encoder$LiteralEncoder$Encoder2","$Create_1","historySize","keepAddBufferBefore","matchMaxLen","keepAddBufferAfter","cyclicBufferSize","hs","_cutValue","keepSizeBefore","keepSizeAfter","keepSizeReserv","blockSize","_keepSizeBefore","_keepSizeAfter","_bufferBase","_blockSize","_pointerToLastSafePosition","$Create_4","_matchMaxLen","_cyclicBufferSize","_son","_hashMask","_hashSizeSum","_hash","$Create_3","$Create_2","Stream","_state","_previousByte","$BaseInit","_position","Low","Range","_cacheSize","_cache","$Init_9","InitBitModels","m_Encoders","$Init_3","Models","$Init_2","_longestMatchWasFound","_optimumEndIndex","_optimumCurrentIndex","_additionalOffset","$Init_4","$FillDistancesPrices","$FillAlignPrices","_tableSize","$UpdateTables","nowPos64","decoder","alive","$Chunker_0","$LZMAByteArrayCompressor","$init_0","r","tmp_length","hex_length","lc","lp","pb","remainder","val","$Decoder$LiteralDecoder$Decoder2","$Create_0","m_LiteralDecoder","numPosStates","$Create","m_LenDecoder","m_RepLenDecoder","m_PosStateMask","$SetLcLpPb","m_DictionarySize","m_DictionarySizeCheck","windowSize","_buffer","_windowSize","_pos","_streamPos","$Create_5","m_OutWindow","$SetDictionarySize","$SetDecoderProperties","m_RangeDecoder","m_IsMatchDecoders","m_IsRepDecoders","m_IsRepG0Decoders","m_IsRepG1Decoders","m_IsRepG2Decoders","m_IsRep0LongDecoders","m_PosSlotDecoder","m_PosDecoders","m_PosAlignDecoder","$BitTreeDecoder","$Decoder$LenDecoder","$Decoder","toString","test","parseInt","inStream","outSize","$ReleaseStream","_stream","m_Decoders","$Init_0","$Init","Code","$Init_8","$Init_1","state","rep0","rep1","rep2","rep3","prevByte","$Chunker","$CodeInChunks","$LZMAByteArrayDecompressor","$GetIndexByte","index","_bufferOffset","$GetMatchLen","distance","limit","pby","_streamEndWasReached","$GetNumAvailableBytes","$ReadBlock","numReadBytes","size","_posLimit","$ReduceOffsets","subValue","CrcTable","j","$MovePos_0","_cyclicBufferPos","numBytes","offset","$MoveBlock","$MovePos_1","$NormalizeLinks","items","numItems","$Flush_0","$GetByte","GetLenToPosState","StateUpdateChar","$processChunkDecode","decoder2","numDirectBits","posSlot","posState","$DecodeBit","$Decode","$Decode_0","startIndex","rangeDecoder","NumBitLevels","bit","bitIndex","symbol","ReverseDecode","numTotalBits","t","$DecodeDirectBits","$ReverseDecode","$CopyBlock","$GetDecoder","$DecodeNormal","matchByte","matchBit","$DecodeWithMatchByte","$PutByte","$CodeOneChunk","inBytesProcessed","outBytesProcessed","$processDecoderChunk","$processChunkEncode","inSize","baseVal","complexState","curByte","footerBits","lenToPosState","posReduced","progressPosValuePrev","subCoder","$Init_5","$Flush","$ReadMatchDistances","$Encode_3","$Encode_1","$GetSubCoder","$GetOptimum","$EncodeMatched","$Encode_0","GetPosSlot","$Encode_2","ReverseEncode","$EncodeDirectBits","$ReverseEncode","_alignPriceCount","_matchPriceCount","$GetProcessedSizeAdd","$CodeOneBlock","$ReleaseMFStream","$ReleaseStreams","$processEncoderChunk","m_NumPosStates","m_LowCoder","m_MidCoder","m_Choice","m_HighCoder","g_FastPos","k","slotFast","c","$Backward","cur","backCur","backMem","posMem","posPrev","PosPrev","BackPrev","Prev1IsChar","$MakeAsChar","Prev2","PosPrev2","BackPrev2","$ReverseGetPrice","st","st2","ReverseGetPrice","$GetPrice_1","nowPos","$WriteEndMarker","$ShiftLow","position","curAnd1Price","curAndLenCharPrice","curAndLenPrice","curBack","curPrice","currentByte","lenEnd","lenMain","lenRes","lenTest","lenTest2","lenTestTemp","matchPrice","newLen","nextIsChar","nextOptimum","nextRepMatchPrice","normalMatchPrice","numAvailableBytes","numAvailableBytesFull","numDistancePairs","offs","opt","optimum","posStateNext","price_4","repIndex","repLen","repMatchPrice","repMaxIndex","shortRepPrice","startLen","state2","$MovePos","State","Price","ProbPrices","$GetPrice_0","$GetRepLen1Price","$MakeAsShortRep","Backs0","Backs1","Backs2","Backs3","$GetPureRepPrice","$GetPrice","$GetPosLenPrice","GetPosSlot2","price","GetPrice","num","curMatch","cyclicPos","delta","hashValue","len0","len1","lenLimit","matchMinPos","pby1","ptr0","ptr1","temp","$Skip","distances","curMatch2","curMatch3","hash2Value","hash3Value","maxLen","$GetMatches","_choice","_lowCoder","_midCoder","_highCoder","$SetPrices","numSymbols","prices","a0","a1","b0","b1","rangeEncoder","$Encode","_counters","_prices","$Encoder$LenEncoder","context","same","matchMode","numBitLevels","probs","newBound","prob","end","start","v","sr","LowHi","Prob","decode","utf","x","y","z","l","charCodes","push","String","fromCharCode","apply","join","encode","ch","chars","elen","srcBegin","srcEnd","dst","dstBegin","srcIdx","charCodeAt","$getChars","toDouble","compress","str","on_finish","on_progress","sync","res","err","error","get_mode_obj","do_action","Date","getTime","bind","decompress","byte_arr","has_progress","d","modes","LZMA","prototype","LZMA_WORKER","self","addEventListener","e"],"mappings":"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"}